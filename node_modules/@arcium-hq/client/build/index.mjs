import { randomBytes, createHash, createCipheriv, createDecipheriv } from 'crypto';
import { ed25519 } from '@noble/curves/ed25519';
export { x25519 } from '@noble/curves/ed25519';
import { shake256, sha3_512 } from '@noble/hashes/sha3';
import { invert, mod, isNegativeLE, pow2 } from '@noble/curves/abstract/modular';
import * as anchor from '@coral-xyz/anchor';
import { Program, EventManager } from '@coral-xyz/anchor';
import { randomBytes as randomBytes$1 } from '@noble/hashes/utils';
import { twistedEdwards } from '@noble/curves/abstract/edwards';
import fs from 'fs';
import { PublicKey, AddressLookupTableProgram } from '@solana/web3.js';

/**
 * Scalar field prime modulus for Curve25519: 2^252 + 27742317777372353535851937790883648493
 */
const CURVE25519_SCALAR_FIELD_MODULUS = ed25519.CURVE.n;
/**
 * Generates a random value within the field bound by q.
 * @param q - The upper bound (exclusive) for the random value.
 * @returns A random bigint value between 0 and q-1.
 */
function generateRandomFieldElem(q) {
    const byteLength = (q.toString(2).length + 7) >> 3;
    let r;
    do {
        const randomBuffer = randomBytes(byteLength);
        r = BigInt(`0x${randomBuffer.toString('hex')}`);
    } while (r >= q);
    return r;
}
/**
 * Computes the positive modulo of a over m.
 * @param a - The dividend.
 * @param m - The modulus.
 * @returns The positive remainder of a mod m.
 */
function positiveModulo(a, m) {
    return ((a % m) + m) % m;
}
/**
 * Serializes a bigint to a little-endian Uint8Array of the specified length.
 * @param val - The bigint value to serialize.
 * @param lengthInBytes - The desired length of the output array.
 * @returns The serialized value as a Uint8Array.
 * @throws Error if the value is too large for the specified length.
 */
function serializeLE(val, lengthInBytes) {
    const result = new Uint8Array(lengthInBytes);
    let tempVal = val;
    for (let i = 0; i < lengthInBytes; i++) {
        result[i] = Number(tempVal & BigInt(255));
        tempVal >>= BigInt(8);
    }
    if (tempVal > BigInt(0)) {
        throw new Error(`Value ${val} is too large for the byte length ${lengthInBytes}`);
    }
    return result;
}
/**
 * Deserializes a little-endian Uint8Array to a bigint.
 * @param bytes - The Uint8Array to deserialize.
 * @returns The deserialized bigint value.
 */
function deserializeLE(bytes) {
    let result = BigInt(0);
    for (let i = 0; i < bytes.length; i++) {
        result |= BigInt(bytes[i]) << (BigInt(i) * BigInt(8));
    }
    return result;
}
// GENERAL
/**
 * Computes the SHA-256 hash of an array of Uint8Arrays.
 * @param byteArrays - The arrays to hash.
 * @returns The SHA-256 hash as a Buffer.
 */
function sha256(byteArrays) {
    const hash = createHash('sha256');
    byteArrays.forEach((byteArray) => {
        hash.update(byteArray);
    });
    return hash.digest();
}

/**
 * Converts a bigint to an array of bits (least significant to most significant, in 2's complement representation).
 * @param x - The bigint to convert.
 * @param binSize - The number of bits to use in the representation.
 * @returns An array of booleans representing the bits of x.
 */
function toBinLE(x, binSize) {
    const res = [];
    for (let i = 0; i < binSize; ++i) {
        res.push(ctSignBit(x, BigInt(i)));
    }
    return res;
}
/**
 * Converts an array of bits (least significant to most significant, in 2's complement representation) to a bigint.
 * @param xBin - The array of bits to convert.
 * @returns The bigint represented by the bit array.
 */
function fromBinLE(xBin) {
    let res = 0n;
    for (let i = 0; i < xBin.length - 1; ++i) {
        res |= BigInt(xBin[i]) << BigInt(i);
    }
    return res - (BigInt(xBin[xBin.length - 1]) << BigInt(xBin.length - 1));
}
/**
 * Binary adder between x and y (assumes xBin and yBin are of the same length and large enough to represent the sum).
 * @param xBin - The first operand as a bit array.
 * @param yBin - The second operand as a bit array.
 * @param carryIn - The initial carry-in value.
 * @param binSize - The number of bits to use in the operation.
 * @returns The sum as a bit array.
 */
function adder(xBin, yBin, carryIn, binSize) {
    const res = [];
    let carry = carryIn;
    for (let i = 0; i < binSize; ++i) {
        // res[i] = xBin[i] XOR yBin[i] XOR carry
        const yXorCarry = yBin[i] !== carry;
        res.push(xBin[i] !== yXorCarry);
        // newCarry = (xBin[i] AND yBin[i]) XOR (xBin[i] AND carry) XOR (yBin[i] AND carry)
        //          = (yBin[i] XOR carry) ? xBin[i] : yBin[i]
        const newCarry = yBin[i] !== (yXorCarry && (xBin[i] !== yBin[i]));
        carry = newCarry;
    }
    return res;
}
/**
 * Constant-time addition of two bigints, using 2's complement representation.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns The sum as a bigint.
 */
function ctAdd(x, y, binSize) {
    const resBin = adder(toBinLE(x, binSize), toBinLE(y, binSize), false, binSize);
    return fromBinLE(resBin);
}
/**
 * Constant-time subtraction of two bigints, using 2's complement representation.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns The difference as a bigint.
 */
function ctSub(x, y, binSize) {
    const yBin = toBinLE(y, binSize);
    const yBinNot = [];
    for (let i = 0; i < binSize; ++i) {
        yBinNot.push(yBin[i] === false);
    }
    const resBin = adder(toBinLE(x, binSize), yBinNot, true, binSize);
    return fromBinLE(resBin);
}
/**
 * Returns the sign bit of a bigint in constant time.
 * @param x - The bigint to check.
 * @param binSize - The bit position to check (typically the highest bit).
 * @returns True if the sign bit is set, false otherwise.
 */
function ctSignBit(x, binSize) {
    return ((x >> binSize) & 1n) === 1n;
}
/**
 * Constant-time less-than comparison for two bigints.
 * @param x - The first operand.
 * @param y - The second operand.
 * @param binSize - The number of bits to use in the operation.
 * @returns True if x < y, false otherwise.
 */
function ctLt(x, y, binSize) {
    return ctSignBit(ctSub(x, y, binSize), binSize);
}
/**
 * Constant-time select between two bigints based on a boolean condition.
 * @param b - The condition; if true, select x, otherwise select y.
 * @param x - The value to select if b is true.
 * @param y - The value to select if b is false.
 * @param binSize - The number of bits to use in the operation.
 * @returns The selected bigint.
 */
function ctSelect(b, x, y, binSize) {
    return ctAdd(y, BigInt(b) * (ctSub(x, y, binSize)), binSize);
}
/**
 * Checks if a bigint fits in the range -2^binSize <= x < 2^binSize.
 * Not constant-time for arbitrary x, but is constant-time for all inputs for which the function returns true.
 * If you assert your inputs satisfy verifyBinSize(x, binSize), you need not care about the non constant-timeness of this function.
 * @param x - The bigint to check.
 * @param binSize - The number of bits to use in the check.
 * @returns True if x fits in the range, false otherwise.
 */
function verifyBinSize(x, binSize) {
    const bin = (x >> binSize).toString(2);
    return bin === '0' || bin === '-1';
}

/**
 * Checks if code is running in a browser environment.
 * @returns true if window object exists, false otherwise
 */
function isBrowser() {
    return (
    // eslint-disable-next-line no-prototype-builtins
    typeof window !== 'undefined' && !window.process?.hasOwnProperty('type'));
}
/**
 * Conditionally logs a message if logging is enabled.
 * @param log - Whether to output the log
 * @param args - Arguments to pass to console.log
 */
function optionalLog(log, ...args) {
    if (log) {
        // eslint-disable-next-line no-console
        console.log(...args);
    }
}
/**
 * Calculates the minimum number of bits needed to represent a value.
 * Formula: floor(log2(max)) + 1 for unsigned, +1 for signed, +1 for diff of two negatives.
 * @param max - The bigint value to measure
 * @returns Number of bits required
 */
function getBinSize(max) {
    // floor(log2(max)) + 1 to represent unsigned elements, a +1 for signed elements
    // and another +1 to account for the diff of two negative elements
    return BigInt(Math.floor(Math.log2(Number(max)))) + 3n;
}
/**
 * Number of mantissa bits for double-precision floating point values.
 */
const DOUBLE_PRECISION_MANTISSA = 52;
/**
 * Encodes a value as a bigint suitable for Rescue encryption, handling booleans, bigints, and numbers.
 * The encoding is performed in constant-time to avoid leaking information through timing side-channels.
 * Throws if the value is out of the supported range for the field.
 * @param v - The value to encode (bigint, number, or boolean).
 * @returns The encoded value as a bigint.
 */
function encodeAsRescueEncryptable(v) {
    if (typeof v === 'boolean') {
        return v ? 1n : 0n;
    }
    if (typeof v === 'bigint') {
        const binSize = getBinSize(CURVE25519_BASE_FIELD.ORDER - 1n);
        if (!verifyBinSize(v, binSize - 1n) || ctLt(v, -(CURVE25519_BASE_FIELD.ORDER - 1n), binSize) || !ctLt(v, CURVE25519_BASE_FIELD.ORDER, binSize)) {
            throw Error(`v must be in the range [${CURVE25519_BASE_FIELD.ORDER - 1n}, ${CURVE25519_BASE_FIELD.ORDER - 1n}]`);
        }
        return ctSelect(ctSignBit(v, binSize), ctAdd(v, CURVE25519_BASE_FIELD.ORDER, binSize), v, binSize);
    }
    if (typeof v === 'number') {
        if (v < -3777893186295716e7 || v >= 2 ** 75) {
            throw new Error('Inputs only supported in the range [-2**75, 2**75)');
        }
        const vBigInt = BigInt(Math.round(v * 2 ** DOUBLE_PRECISION_MANTISSA));
        const binSize = getBinSize(CURVE25519_BASE_FIELD.ORDER - 1n);
        return ctSelect(ctSignBit(vBigInt, binSize), ctAdd(vBigInt, CURVE25519_BASE_FIELD.ORDER, binSize), vBigInt, binSize);
    }
    throw new Error('Invalid type to convert from number to bigint');
}
/**
 * Decodes a Rescue-decrypted value back to a signed bigint.
 * Handles the conversion from field element representation to signed integer.
 * @param v - The decrypted field element value
 * @returns The decoded signed bigint value
 */
function decodeRescueDecryptedToBigInt(v) {
    const twoInv = (CURVE25519_BASE_FIELD.ORDER + 1n) / 2n;
    const binSize = getBinSize(CURVE25519_BASE_FIELD.ORDER - 1n);
    const isLtTwoInv = ctLt(v, twoInv, binSize);
    return ctSelect(isLtTwoInv, v, ctSub(v, CURVE25519_BASE_FIELD.ORDER, binSize), binSize);
}
/**
 * Decodes a Rescue-decrypted value back to a JavaScript number.
 * Converts from field element representation to a floating-point number.
 * @param v - The decrypted field element value
 * @returns The decoded number value
 */
function decodeRescueDecryptedToNumber(v) {
    const vSigned = decodeRescueDecryptedToBigInt(v);
    return Number(vSigned) * 2 ** -DOUBLE_PRECISION_MANTISSA;
}
/**
 * Checks if a computation reference is null (all zeros).
 * @param ref - The computation reference to check
 * @returns true if the reference is null, false otherwise
 */
function isNullRef(ref) {
    const bigZero = new anchor.BN(0);
    return (ref.computationOffset === bigZero
        && ref.priorityFee === bigZero);
}

/**
 * Matrix class over FpField. Data is row-major.
 */
class Matrix {
    field;
    data;
    constructor(field, data) {
        this.field = field;
        const nrows = data.length;
        const ncols = data[0].length;
        for (let i = 1; i < nrows; ++i) {
            if (data[i].length !== ncols) {
                throw Error('All rows must have same number of columns.');
            }
        }
        this.data = data.map((row) => row.map((c) => field.create(c)));
    }
    /**
     * Matrix multiplication between `this` and `rhs`.
     */
    matMul(rhs) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNcols !== rhsNrows) {
            throw Error(`this.ncols must be equal to rhs.nrows (found ${thisNcols} and ${rhsNrows})`);
        }
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < rhsNcols; ++j) {
                let c = this.field.ZERO;
                for (let k = 0; k < thisNcols; ++k) {
                    c = this.field.add(c, this.field.mul(this.data[i][k], rhs.data[k][j]));
                }
                row.push(c);
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Element-wise addition between `this` and `rhs`.
     */
    add(rhs, ct = false) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNrows !== rhsNrows) {
            throw Error(`this.nrows must be equal to rhs.nrows (found ${thisNrows} and ${rhsNrows})`);
        }
        if (thisNcols !== rhsNcols) {
            throw Error(`this.ncols must be equal to rhs.ncols (found ${thisNcols} and ${rhsNcols})`);
        }
        const binSize = getBinSize(this.field.ORDER - 1n);
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < thisNcols; ++j) {
                if (ct) {
                    const sum = ctAdd(this.data[i][j], rhs.data[i][j], binSize);
                    row.push(ctSelect(ctLt(sum, this.field.ORDER, binSize), sum, ctSub(sum, this.field.ORDER, binSize), binSize));
                }
                else {
                    row.push(this.field.add(this.data[i][j], rhs.data[i][j]));
                }
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Element-wise subtraction between `this` and `rhs`.
     */
    sub(rhs, ct = false) {
        const thisNrows = this.data.length;
        const thisNcols = this.data[0].length;
        const rhsNrows = rhs.data.length;
        const rhsNcols = rhs.data[0].length;
        if (thisNrows !== rhsNrows) {
            throw Error(`this.nrows must be equal to rhs.nrows (found ${thisNrows} and ${rhsNrows})`);
        }
        if (thisNcols !== rhsNcols) {
            throw Error(`this.ncols must be equal to rhs.ncols (found ${thisNcols} and ${rhsNcols})`);
        }
        const binSize = getBinSize(this.field.ORDER - 1n);
        const data = [];
        for (let i = 0; i < thisNrows; ++i) {
            const row = [];
            for (let j = 0; j < thisNcols; ++j) {
                if (ct) {
                    const diff = ctSub(this.data[i][j], rhs.data[i][j], binSize);
                    row.push(ctSelect(ctSignBit(diff, binSize), ctAdd(diff, this.field.ORDER, binSize), diff, binSize));
                }
                else {
                    row.push(this.field.sub(this.data[i][j], rhs.data[i][j]));
                }
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * Raises each element of `this` to the power `e`.
     */
    pow(e) {
        const data = [];
        for (let i = 0; i < this.data.length; ++i) {
            const row = [];
            for (let j = 0; j < this.data[0].length; ++j) {
                row.push(this.field.pow(this.data[i][j], e));
            }
            data.push(row);
        }
        return new Matrix(this.field, data);
    }
    /**
     * computs the determinant using gaus elimination
     * matches the determinant implementation in arcis
     */
    det() {
        // Ensure the matrix is square
        const n = this.data.length;
        if (n === 0 || !this.is_square()) {
            throw Error('Matrix must be square and non-empty to compute the determinant.');
        }
        let det = this.field.ONE;
        // Clone the data to avoid mutating the original matrix
        let rows = this.data.map((row) => [...row]);
        for (let i = 0; i < n; ++i) {
            // we partition into rows that have a leading zero and rows that don't
            const lzRows = rows.filter((r) => this.field.is0(r[0]));
            const nlzRows = rows.filter((r) => !this.field.is0(r[0]));
            // take pivot element
            const pivotRow = nlzRows.shift();
            if (pivotRow === undefined) {
                // no pivot row implies the rank is less than n i.e. the determinant is zero
                return this.field.ZERO;
            }
            const pivot = pivotRow[0];
            // multiply pivot onto the determinant
            det = this.field.mul(det, pivot);
            // subtract all leading non zero values with the pivot element (forward elimination).
            const pivotInverse = this.field.inv(pivot);
            // precomputing pivot row such that the leading value is one. This reduces the number of
            // multiplications in the forward elimination multiplications by 50%
            const normalizedPivotRow = pivotRow.map((v) => this.field.mul(pivotInverse, v));
            // forward elimination with normalized pivot row
            const nlzRowsProcessed = nlzRows.map((row) => {
                const lead = row[0];
                return row.map((value, index) => this.field.sub(value, this.field.mul(lead, normalizedPivotRow[index])));
            });
            // concat the reamining rows (without pivot row) and remove the pivot column (all first
            // elements (i.e. zeros) from the remaining rows).
            rows = nlzRowsProcessed.concat(lzRows).map((row) => row.slice(1));
        }
        return det;
    }
    is_square() {
        const n = this.data.length;
        for (let i = 1; i < n; ++i) {
            if (this.data[i].length !== n) {
                return false;
            }
        }
        return true;
    }
}
function randMatrix(field, nrows, ncols) {
    const data = [];
    for (let i = 0; i < nrows; ++i) {
        const row = [];
        for (let j = 0; j < ncols; ++j) {
            row.push(generateRandomFieldElem(field.ORDER));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}

/**
 * Curve25519 base field as an IField instance.
 */
const CURVE25519_BASE_FIELD = ed25519.Point.Fp;
/**
 * Curve25519 scalar field as an IField instance.
 */
const CURVE25519_SCALAR_FIELD = ed25519.Point.Fn;
// Security level for the block cipher.
const SECURITY_LEVEL_BLOCK_CIPHER = 128;
// Security level for the hash function.
const SECURITY_LEVEL_HASH_FUNCTION = 256;
// We refer to https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287 for more details.
/**
 * Description and parameters for the Rescue cipher or hash function, including round constants, MDS matrix, and key schedule.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class RescueDesc {
    mode;
    field;
    // The smallest prime that does not divide p-1.
    alpha;
    // The inverse of alpha modulo p-1.
    alphaInverse;
    nRounds;
    m;
    // A Maximum Distance Separable matrix.
    mdsMat;
    // Its inverse.
    mdsMatInverse;
    // The round keys, needed for encryption and decryption.
    roundKeys;
    /**
     * Constructs a RescueDesc for a given field and mode (cipher or hash).
     * Initializes round constants, MDS matrix, and key schedule.
     * @param field - The field to use (e.g., CURVE25519_BASE_FIELD).
     * @param mode - The mode: block cipher or hash function.
     */
    constructor(field, mode) {
        this.field = field;
        this.mode = mode;
        switch (this.mode.kind) {
            case 'cipher': {
                this.m = this.mode.key.length;
                if (this.m < 2) {
                    throw Error(`parameter m must be at least 2 (found ${this.m})`);
                }
                break;
            }
            case 'hash': {
                this.m = this.mode.m;
                break;
            }
            default: {
                this.m = 0;
                break;
            }
        }
        const alphaAndInverse = getAlphaAndInverse(this.field.ORDER);
        this.alpha = alphaAndInverse[0];
        this.alphaInverse = alphaAndInverse[1];
        this.nRounds = getNRounds(this.field.ORDER, this.mode, this.alpha, this.m);
        const mdsMatrixAndInverse = getMdsMatrixAndInverse(this.field, this.m);
        this.mdsMat = mdsMatrixAndInverse[0];
        this.mdsMatInverse = mdsMatrixAndInverse[1];
        // generate the round constants using SHAKE256
        const roundConstants = this.sampleConstants(this.nRounds);
        switch (this.mode.kind) {
            case 'cipher': {
                // do the key schedule
                this.roundKeys = rescuePermutation(this.mode, this.alpha, this.alphaInverse, this.mdsMat, roundConstants, new Matrix(this.field, toVec(this.mode.key)));
                break;
            }
            case 'hash': {
                this.roundKeys = roundConstants;
                break;
            }
            default: {
                this.roundKeys = [];
                break;
            }
        }
    }
    /**
     * Samples round constants for the Rescue permutation, using SHAKE256.
     * @param nRounds - The number of rounds.
     * @returns An array of round constant matrices.
     */
    sampleConstants(nRounds) {
        const field = this.field;
        const m = this.m;
        // setup randomness
        // dkLen is the output length from the Keccak instance behind shake.
        // this is irrelevant for our extendable output function (xof), but still we use
        // the default value from one-time shake256 hashing, as defined in shake256's definition
        // in noble-hashes-sha3.
        const hasher = shake256.create({ dkLen: 256 / 8 });
        // buffer to create field elements from bytes
        // we add 16 bytes to get a distribution statistically close to uniform
        const bufferLen = Math.ceil(field.BITS / 8) + 16;
        switch (this.mode.kind) {
            case 'cipher': {
                hasher.update('encrypt everything, compute anything');
                const rFieldArray = Array.from({ length: m * m + 2 * m }, () => {
                    // create field element from the shake hash
                    const randomness = hasher.xof(bufferLen);
                    // we need not check whether the obtained field element f is in any subgroup,
                    // because we use only prime fields (i.e. there are no subgroups)
                    return field.create(deserializeLE(randomness));
                });
                // create matrix and vectors
                const matData = Array.from({ length: m }, () => rFieldArray.splice(0, m));
                let roundConstantMat = new Matrix(field, matData);
                const initData = Array.from({ length: m }, () => rFieldArray.splice(0, 1));
                const initialRoundConstant = new Matrix(field, initData);
                const roundData = Array.from({ length: m }, () => rFieldArray.splice(0, 1));
                const roundConstantAffineTerm = new Matrix(field, roundData);
                // check for inversability
                while (field.is0(roundConstantMat.det())) {
                    // resample matrix
                    const resampleArray = Array.from({ length: m * m }, () => {
                        const randomness = hasher.xof(bufferLen);
                        return field.create(deserializeLE(randomness));
                    });
                    const resampleData = Array.from({ length: m }, () => resampleArray.splice(0, m));
                    roundConstantMat = new Matrix(field, resampleData);
                }
                const roundConstants = [initialRoundConstant];
                for (let r = 0; r < 2 * this.nRounds; ++r) {
                    roundConstants.push(roundConstantMat.matMul(roundConstants[r]).add(roundConstantAffineTerm));
                }
                return roundConstants;
            }
            case 'hash': {
                hasher.update(`Rescue-XLIX(${this.field.ORDER},${m},${this.mode.capacity},${SECURITY_LEVEL_HASH_FUNCTION})`);
                // this.permute requires an odd number of round keys
                // prepending a 0 matrix makes it equivalent to Algorithm 3 from https://eprint.iacr.org/2020/1143.pdf
                const zeros = [];
                for (let i = 0; i < m; ++i) {
                    zeros.push([0n]);
                }
                const roundConstants = [new Matrix(field, zeros)];
                const rFieldArray = Array.from({ length: 2 * m * nRounds }, () => {
                    // create field element from the shake hash
                    const randomness = hasher.xof(bufferLen);
                    // we need not check whether the obtained field element f is in any subgroup,
                    // because we use only prime fields (i.e. there are no subgroups)
                    return field.create(deserializeLE(randomness));
                });
                for (let r = 0; r < 2 * nRounds; ++r) {
                    const data = [];
                    for (let i = 0; i < m; ++i) {
                        data.push([rFieldArray[r * m + i]]);
                    }
                    roundConstants.push(new Matrix(field, data));
                }
                return roundConstants;
            }
            default: return [];
        }
    }
    /**
     * Applies the Rescue permutation to a state matrix.
     * @param state - The input state matrix.
     * @returns The permuted state matrix.
     */
    permute(state) {
        return rescuePermutation(this.mode, this.alpha, this.alphaInverse, this.mdsMat, this.roundKeys, state)[2 * this.nRounds];
    }
    /**
     * Applies the inverse Rescue permutation to a state matrix.
     * @param state - The input state matrix.
     * @returns The inverse-permuted state matrix.
     */
    permuteInverse(state) {
        return rescuePermutationInverse(this.mode, this.alpha, this.alphaInverse, this.mdsMatInverse, this.roundKeys, state)[2 * this.nRounds];
    }
}
/**
 * Finds the smallest prime alpha that does not divide p-1, and computes its inverse modulo p-1.
 * The alpha parameter is used in the Rescue permutation for exponentiation operations.
 * @param p - The field modulus (prime number)
 * @returns A tuple [alpha, alphaInverse] where alpha is the prime and alphaInverse is its modular inverse
 * @throws Error if no suitable prime alpha is found
 */
function getAlphaAndInverse(p) {
    const pMinusOne = p - 1n;
    let alpha = 0n;
    for (const a of [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n]) {
        if (pMinusOne % a !== 0n) {
            alpha = a;
            break;
        }
    }
    if (alpha === 0n) {
        throw Error('Could not find prime alpha that does not divide p-1.');
    }
    const alphaInverse = invert(alpha, pMinusOne);
    return [alpha, alphaInverse];
}
/**
 * Calculates the number of rounds required for the Rescue permutation based on security analysis.
 * The number of rounds is determined by analyzing resistance to differential and algebraic attacks.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287 for the security analysis.
 * @param p - The field modulus
 * @param mode - The Rescue mode (cipher or hash)
 * @param alpha - The prime alpha parameter
 * @param m - The state size (block size for cipher, total size for hash)
 * @returns The number of rounds (will be doubled for the full permutation)
 */
function getNRounds(p, mode, alpha, m) {
    function dcon(n) {
        return Math.floor(0.5 * (Number(alpha) - 1) * m * (n - 1) + 2.0);
    }
    function v(n, rate) {
        return m * (n - 1) + rate;
    }
    function binomial(n, k) {
        function factorial(x) {
            if (x === 0n || x === 1n) {
                return 1n;
            }
            return x * factorial(x - 1n);
        }
        return factorial(BigInt(n)) / (factorial(BigInt(n - k)) * factorial(BigInt(k)));
    }
    switch (mode.kind) {
        case 'cipher': {
            const l0 = Math.ceil((2 * SECURITY_LEVEL_BLOCK_CIPHER) / ((m + 1) * (Math.log2(Number(p)) - Math.log2(Number(alpha) - 1))));
            let l1 = 0;
            if (alpha === 3n) {
                l1 = Math.ceil((SECURITY_LEVEL_BLOCK_CIPHER + 2) / (4 * m));
            }
            else {
                l1 = Math.ceil((SECURITY_LEVEL_BLOCK_CIPHER + 3) / (5.5 * m));
            }
            return 2 * Math.max(l0, l1, 5);
        }
        case 'hash': {
            // get number of rounds for Groebner basis attack
            const rate = m - mode.capacity;
            const target = 1n << BigInt(SECURITY_LEVEL_HASH_FUNCTION);
            let l1 = 1;
            let tmp = binomial(v(l1, rate) + dcon(l1), v(l1, rate));
            while (tmp * tmp <= target && l1 <= 23) {
                l1 += 1;
                tmp = binomial(v(l1, rate) + dcon(l1), v(l1, rate));
            }
            // set a minimum value for sanity and add 50%
            return Math.ceil(1.5 * Math.max(5, l1));
        }
        default: return 0;
    }
}
/**
 * Builds a Cauchy matrix for use as an MDS (Maximum Distance Separable) matrix.
 * A Cauchy matrix is guaranteed to be invertible and provides optimal diffusion properties.
 * The matrix is constructed using the formula: M[i][j] = 1/(i + j) for i, j in [1, size].
 * @param field - The finite field over which to construct the matrix
 * @param size - The size of the square matrix
 * @returns A Cauchy matrix of the specified size
 */
function buildCauchy(field, size) {
    const data = [];
    for (let i = 1n; i <= size; ++i) {
        const row = [];
        for (let j = 1n; j <= size; ++j) {
            row.push(field.inv(i + j));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}
/**
 * Builds the inverse of a Cauchy matrix for use as the inverse MDS matrix.
 * The inverse is computed using a closed-form formula for Cauchy matrix inversion.
 * @param field - The finite field over which to construct the matrix
 * @param size - The size of the square matrix
 * @returns The inverse of the Cauchy matrix
 */
function buildInverseCauchy(field, size) {
    function product(arr) {
        return arr.reduce((acc, curr) => field.mul(acc, field.create(curr)), field.ONE);
    }
    function prime(arr, val) {
        return product(arr.map((u) => {
            if (u !== val) {
                return val - u;
            }
            return 1n;
        }));
    }
    const data = [];
    for (let i = 1n; i <= size; ++i) {
        const row = [];
        for (let j = 1n; j <= size; ++j) {
            const a = product(Array.from({ length: size }, (_, key) => -i - BigInt(1 + key)));
            const aPrime = prime(Array.from({ length: size }, (_, key) => BigInt(1 + key)), j);
            const b = product(Array.from({ length: size }, (_, key) => j + BigInt(1 + key)));
            const bPrime = prime(Array.from({ length: size }, (_, key) => -BigInt(1 + key)), -i);
            row.push(field.mul(a, field.mul(b, field.mul(field.inv(aPrime), field.mul(field.inv(bPrime), field.inv(-i - j))))));
        }
        data.push(row);
    }
    return new Matrix(field, data);
}
function getMdsMatrixAndInverse(field, m) {
    const mdsMat = buildCauchy(field, m);
    const mdsMatInverse = buildInverseCauchy(field, m);
    return [mdsMat, mdsMatInverse];
}
function exponentForEven(mode, alpha, alphaInverse) {
    switch (mode.kind) {
        case 'cipher': {
            return alphaInverse;
        }
        case 'hash': {
            return alpha;
        }
        default: return 0n;
    }
}
function exponentForOdd(mode, alpha, alphaInverse) {
    switch (mode.kind) {
        case 'cipher': {
            return alpha;
        }
        case 'hash': {
            return alphaInverse;
        }
        default: return 0n;
    }
}
/**
 * Core Rescue permutation function implementing the cryptographic primitive.
 * Applies alternating rounds of exponentiation and MDS matrix multiplication with round keys.
 * The permutation alternates between using alpha and alphaInverse as exponents based on round parity.
 * This is the fundamental building block for both Rescue cipher and Rescue-Prime hash.
 * @param mode - The Rescue mode (cipher or hash) determining exponent selection
 * @param alpha - The prime exponent for even rounds
 * @param alphaInverse - The inverse exponent for odd rounds
 * @param mdsMat - The Maximum Distance Separable matrix for diffusion
 * @param subkeys - Array of round key matrices
 * @param state - The initial state matrix to permute
 * @returns Array of all intermediate states during the permutation
 */
function rescuePermutation(mode, alpha, alphaInverse, mdsMat, subkeys, state) {
    const exponentEven = exponentForEven(mode, alpha, alphaInverse);
    const exponentOdd = exponentForOdd(mode, alpha, alphaInverse);
    const states = [state.add(subkeys[0])];
    for (let r = 0; r < subkeys.length - 1; ++r) {
        let s = states[r];
        if (r % 2 === 0) {
            s = s.pow(exponentEven);
        }
        else {
            s = s.pow(exponentOdd);
        }
        states.push(mdsMat.matMul(s).add(subkeys[r + 1]));
    }
    return states;
}
function rescuePermutationInverse(mode, alpha, alphaInverse, mdsMatInverse, subkeys, state) {
    const exponentEven = exponentForEven(mode, alpha, alphaInverse);
    const exponentOdd = exponentForOdd(mode, alpha, alphaInverse);
    // the initial state will need to be removed afterwards
    const states = [state];
    for (let r = 0; r < subkeys.length - 1; ++r) {
        let s = states[r];
        s = mdsMatInverse.matMul(s.sub(subkeys[subkeys.length - 1 - r]));
        if (r % 2 === 0) {
            s = s.pow(exponentEven);
        }
        else {
            s = s.pow(exponentOdd);
        }
        states.push(s);
    }
    states.push(states[states.length - 1].sub(subkeys[0]));
    states.shift();
    return states;
}
function toVec(data) {
    const dataVec = [];
    for (let i = 0; i < data.length; ++i) {
        dataVec.push([data[i]]);
    }
    return dataVec;
}

/**
 * The Rescue-Prime hash function, as described in https://eprint.iacr.org/2020/1143.pdf, offering 256 bits
 * of security against collision, preimage and second-preimage attacks for any field of size at least 102 bits.
 * We use the sponge construction with fixed rate = 7 and capacity = 5 (i.e., m = 12), and truncate the
 * output to 5 field elements.
 */
class RescuePrimeHash {
    desc;
    rate;
    digestLength;
    /**
     * Constructs a RescuePrimeHash instance with rate = 7 and capacity = 5.
     */
    constructor(field) {
        this.desc = new RescueDesc(field, { kind: 'hash', m: 12, capacity: 5 });
        this.rate = 7;
        this.digestLength = 5;
    }
    // This is Algorithm 1 from https://eprint.iacr.org/2020/1143.pdf, though with the padding (see Algorithm 2).
    // The hash is truncated to digestLength elements.
    // According to Section 2.2, this offers min(log2(CURVE25519_BASE_FIELD.ORDER) / 2 * min(digestLength, capacity), s)
    // bits of security against collision, preimage and second-preimage attacks.
    // The security level is thus of the order of 256 bits for any field of size at least 102 bits.
    // The rate and capacity are chosen to achieve minimal number of rounds 8.
    /**
     * Computes the Rescue-Prime hash of a message, with padding as described in Algorithm 2 of the paper.
     * @param message - The input message as an array of bigints.
     * @returns The hash output as an array of bigints (length = digestLength).
     */
    digest(message) {
        // Create a copy and pad message to avoid mutating input parameter
        const paddedMessage = [...message, 1n];
        while (paddedMessage.length % this.rate !== 0) {
            paddedMessage.push(0n);
        }
        const zeros = [];
        for (let i = 0; i < this.desc.m; ++i) {
            zeros.push([0n]);
        }
        let state = new Matrix(this.desc.field, zeros);
        for (let r = 0; r < paddedMessage.length / this.rate; ++r) {
            const data = [];
            for (let i = 0; i < this.rate; ++i) {
                data[i] = [paddedMessage[r * this.rate + i]];
            }
            for (let i = this.rate; i < this.desc.m; ++i) {
                data[i] = [0n];
            }
            const s = new Matrix(this.desc.field, data);
            state = this.desc.permute(state.add(s, true));
        }
        const res = [];
        for (let i = 0; i < this.digestLength; ++i) {
            res.push(state.data[i][0]);
        }
        return res;
    }
}

/**
 * Block size m for Rescue cipher operations.
 * Rescue operates on 5-element blocks of field elements.
 */
const RESCUE_CIPHER_BLOCK_SIZE = 5;
/**
 * The Rescue cipher in Counter (CTR) mode, with a fixed block size m = 5.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class RescueCipherCommon {
    desc;
    /**
     * Constructs a RescueCipherCommon instance using a shared secret.
     * The key is derived using RescuePrimeHash and used to initialize the RescueDesc.
     * @param sharedSecret - The shared secret to derive the cipher key from.
     */
    constructor(sharedSecret, field) {
        if (sharedSecret.length != 32) {
            throw Error(`sharedSecret must be of length 32 (found ${sharedSecret.length})`);
        }
        const hasher = new RescuePrimeHash(field);
        // In case `field` is different from CURVE25519_BASE_FIELD we need to injectively map sharedSecret
        // to a vector of elements over `field`.
        const converted = [];
        if (field === CURVE25519_BASE_FIELD) {
            converted.push(deserializeLE(sharedSecret));
        }
        else {
            // We chunk sharedSecret by field.BYTES - 1 and convert.
            const chunkSize = field.BYTES - 1;
            const nChunks = Math.ceil(sharedSecret.length / chunkSize);
            for (let i = 0; i < nChunks; ++i) {
                converted.push(deserializeLE(sharedSecret.slice(i * chunkSize, (i + 1) * chunkSize)));
            }
        }
        // We follow [Section 4, Option 1.](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr2.pdf).
        // For our choice of hash function, we have:
        // - H_outputBits = hasher.digestLength = RESCUE_CIPHER_BLOCK_SIZE
        // - max_H_inputBits = arbitrarily long, as the Rescue-Prime hash function is built upon the
        //   sponge construction
        // - L = RESCUE_CIPHER_BLOCK_SIZE.
        // Build the vector `counter || Z || FixedInfo` (we only have i = 1, since reps = 1).
        // For the FixedInfo we simply take L.
        const counter = [1n, ...converted, BigInt(RESCUE_CIPHER_BLOCK_SIZE)];
        const rescueKey = hasher.digest(counter);
        this.desc = new RescueDesc(field, { kind: 'cipher', key: rescueKey });
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode (raw, returns bigints).
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of bigints.
     * @throws Error if the nonce is not 16 bytes long.
     */
    encrypt_raw(plaintext, nonce) {
        if (nonce.length !== 16) {
            throw Error(`nonce must be of length 16 (found ${nonce.length})`);
        }
        const binSize = getBinSize(this.desc.field.ORDER - 1n);
        function encryptBatch(desc, ptxt, cntr) {
            if (cntr.length !== RESCUE_CIPHER_BLOCK_SIZE) {
                throw Error(`counter must be of length ${RESCUE_CIPHER_BLOCK_SIZE} (found ${cntr.length})`);
            }
            const encryptedCounter = desc.permute(new Matrix(desc.field, toVec(cntr)));
            const ciphertext = [];
            for (let i = 0; i < ptxt.length; ++i) {
                if (!verifyBinSize(ptxt[i], binSize - 1n) || ctSignBit(ptxt[i], binSize) || !ctLt(ptxt[i], desc.field.ORDER, binSize)) {
                    throw Error(`plaintext must be non-negative and less than ${desc.field.ORDER}`);
                }
                const sum = ctAdd(ptxt[i], encryptedCounter.data[i][0], binSize);
                ciphertext.push(ctSelect(ctLt(sum, desc.field.ORDER, binSize), sum, ctSub(sum, desc.field.ORDER, binSize), binSize));
            }
            return ciphertext;
        }
        const nBlocks = Math.ceil(plaintext.length / RESCUE_CIPHER_BLOCK_SIZE);
        const counter = getCounter(deserializeLE(nonce), nBlocks);
        const ciphertext = [];
        for (let i = 0; i < nBlocks; ++i) {
            const cnt = RESCUE_CIPHER_BLOCK_SIZE * i;
            const newCiphertext = encryptBatch(this.desc, plaintext.slice(cnt, Math.min(cnt + RESCUE_CIPHER_BLOCK_SIZE, plaintext.length)), counter.slice(cnt, cnt + RESCUE_CIPHER_BLOCK_SIZE));
            for (let j = 0; j < newCiphertext.length; ++j) {
                ciphertext.push(newCiphertext[j]);
            }
        }
        return ciphertext;
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode and serializes each block.
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of arrays of numbers (each 32 bytes).
     */
    encrypt(plaintext, nonce) {
        return this.encrypt_raw(plaintext, nonce).map((c) => Array.from(serializeLE(c, 32)));
    }
    /**
     * Decrypts the ciphertext vector in Counter (CTR) mode (raw, expects bigints).
     * @param ciphertext - The array of ciphertext bigints to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     * @throws Error if the nonce is not 16 bytes long.
     */
    decrypt_raw(ciphertext, nonce) {
        if (nonce.length !== 16) {
            throw Error(`nonce must be of length 16 (found ${nonce.length})`);
        }
        const binSize = getBinSize(this.desc.field.ORDER - 1n);
        function decryptBatch(desc, ctxt, cntr) {
            if (cntr.length !== RESCUE_CIPHER_BLOCK_SIZE) {
                throw Error(`counter must be of length ${RESCUE_CIPHER_BLOCK_SIZE} (found ${cntr.length})`);
            }
            const encryptedCounter = desc.permute(new Matrix(desc.field, toVec(cntr)));
            const decrypted = [];
            for (let i = 0; i < ctxt.length; ++i) {
                const diff = ctSub(ctxt[i], encryptedCounter.data[i][0], binSize);
                decrypted.push(ctSelect(ctSignBit(diff, binSize), ctAdd(diff, desc.field.ORDER, binSize), diff, binSize));
            }
            return decrypted;
        }
        const nBlocks = Math.ceil(ciphertext.length / RESCUE_CIPHER_BLOCK_SIZE);
        const counter = getCounter(deserializeLE(nonce), nBlocks);
        const decrypted = [];
        for (let i = 0; i < nBlocks; ++i) {
            const cnt = RESCUE_CIPHER_BLOCK_SIZE * i;
            const newDecrypted = decryptBatch(this.desc, ciphertext.slice(cnt, Math.min(cnt + RESCUE_CIPHER_BLOCK_SIZE, ciphertext.length)), counter.slice(cnt, cnt + RESCUE_CIPHER_BLOCK_SIZE));
            for (let j = 0; j < newDecrypted.length; ++j) {
                decrypted.push(newDecrypted[j]);
            }
        }
        return decrypted;
    }
    /**
     * Deserializes and decrypts the ciphertext vector in Counter (CTR) mode.
     * @param ciphertext - The array of arrays of numbers (each 32 bytes) to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     */
    decrypt(ciphertext, nonce) {
        return this.decrypt_raw(ciphertext.map((c) => {
            if (c.length !== 32) {
                throw Error(`ciphertext must be of length 32 (found ${c.length})`);
            }
            return deserializeLE(Uint8Array.from(c));
        }), nonce);
    }
}
/**
 * Generates the counter values for Rescue cipher CTR mode.
 * @param nonce - The initial nonce as a bigint.
 * @param nBlocks - The number of blocks to generate counters for.
 * @returns An array of counter values as bigints.
 */
function getCounter(nonce, nBlocks) {
    const counter = [];
    for (let i = 0n; i < nBlocks; ++i) {
        counter.push(nonce);
        counter.push(i);
        // Pad to RESCUE_CIPHER_BLOCK_SIZE elements per counter block
        for (let j = 2; j < RESCUE_CIPHER_BLOCK_SIZE; ++j) {
            counter.push(0n);
        }
    }
    return counter;
}

/**
 * The Rescue cipher over Curve25519's base field in Counter (CTR) mode, with a fixed block size m = 5.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class RescueCipher {
    cipher;
    /**
     * Constructs a RescueCipher instance using a shared secret.
     * The key is derived using RescuePrimeHash and used to initialize the RescueDesc.
     * @param sharedSecret - The shared secret to derive the cipher key from.
     */
    constructor(sharedSecret) {
        this.cipher = new RescueCipherCommon(sharedSecret, CURVE25519_BASE_FIELD);
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode and serializes each block.
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of arrays of numbers (each 32 bytes).
     */
    encrypt(plaintext, nonce) {
        return this.cipher.encrypt(plaintext, nonce);
    }
    /**
     * Deserializes and decrypts the ciphertext vector in Counter (CTR) mode.
     * @param ciphertext - The array of arrays of numbers (each 32 bytes) to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     */
    decrypt(ciphertext, nonce) {
        return this.cipher.decrypt(ciphertext, nonce);
    }
}

/**
 * The Rescue cipher over Curve25519's scalar field in Counter (CTR) mode, with a fixed block size m = 5.
 * See: https://tosc.iacr.org/index.php/ToSC/article/view/8695/8287
 */
class CSplRescueCipher {
    cipher;
    /**
     * Constructs a RescueCipher instance using a shared secret.
     * The key is derived using RescuePrimeHash and used to initialize the RescueDesc.
     * @param sharedSecret - The shared secret to derive the cipher key from.
     */
    constructor(sharedSecret) {
        this.cipher = new RescueCipherCommon(sharedSecret, CURVE25519_SCALAR_FIELD);
    }
    /**
     * Encrypts the plaintext vector in Counter (CTR) mode and serializes each block.
     * @param plaintext - The array of plaintext bigints to encrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The ciphertext as an array of arrays of numbers (each 32 bytes).
     */
    encrypt(plaintext, nonce) {
        return this.cipher.encrypt(plaintext, nonce);
    }
    /**
     * Deserializes and decrypts the ciphertext vector in Counter (CTR) mode.
     * @param ciphertext - The array of arrays of numbers (each 32 bytes) to decrypt.
     * @param nonce - A 16-byte nonce for CTR mode.
     * @returns The decrypted plaintext as an array of bigints.
     */
    decrypt(ciphertext, nonce) {
        return this.cipher.decrypt(ciphertext, nonce);
    }
}

// The arcisEd25519 signature scheme. This is essentially ed25519 but we use the hash function
// SHA3-512 instead of SHA-512 since its multiplicative depth is much lower, which
// makes it much better suited to be evaluated in MPC.
// Those are the parameters specified [here](https://datatracker.ietf.org/doc/html/rfc8032#section-5.1)
// (except for the hash function, see above). The below is copied from [here](https://github.com/paulmillr/noble-curves/blob/main/src/ed25519.ts).
const arcisEd25519Defaults = (() => ({
    a: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819948'),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    Fp: ed25519.CURVE.Fp,
    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),
    hash: sha3_512,
    randomBytes: randomBytes$1,
    adjustScalarBytes,
    uvRatio,
}))();
/**
 * Ed25519 curve instance using SHA3-512 for hashing, suitable for MPC (ArcisEd25519 signature scheme).
 * This is essentially Ed25519 but with SHA3-512 instead of SHA-512 for lower multiplicative depth.
 * See: https://datatracker.ietf.org/doc/html/rfc8032#section-5.1
 */
const arcisEd25519 = (() => twistedEdwards(arcisEd25519Defaults))();
// Helper function for the sqrt in Fp.
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519.CURVE.Fp.ORDER;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = (pow2(b2, 2n, P) * b2) % P; // x^15, 1111
    const b5 = (pow2(b4, 1n, P) * x) % P; // x^31
    const b10 = (pow2(b5, 5n, P) * b5) % P;
    const b20 = (pow2(b10, _10n, P) * b10) % P;
    const b40 = (pow2(b20, _20n, P) * b20) % P;
    const b80 = (pow2(b40, _40n, P) * b40) % P;
    const b160 = (pow2(b80, _80n, P) * b80) % P;
    const b240 = (pow2(b160, _80n, P) * b80) % P;
    const b250 = (pow2(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = (pow2(b250, 2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
/**
 * Clamps a 32-byte scalar as required by the Ed25519 signature scheme.
 * See: https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.5
 * @param bytes - The 32-byte scalar to clamp.
 * @returns The clamped scalar as a Uint8Array.
 */
function adjustScalarBytes(bytes) {
    const clamped = bytes;
    clamped[0] &= 248;
    clamped[31] &= 127;
    clamped[31] |= 64;
    return clamped;
}
/**
 * Helper function for decompression, calculating (u/v).
 * @returns An object with isValid and value.
 */
function uvRatio(u, v) {
    const P = ed25519.CURVE.Fp.ORDER;
    const v3 = mod(v * v * v, P); // v
    const v7 = mod(v3 * v3 * v, P); // v
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8
    const vx2 = mod(v * x * x, P); // vx
    const root1 = x; // First root candidate
    const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root
    const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if (isNegativeLE(x, P))
        x = mod(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}

/**
 * Mapping from key bits to key byte length.
 */
const KEY_BYTES = { 128: 16, 192: 24, 256: 32 };
/**
 * Generic AES cipher in Counter (CTR) mode, using SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class AesCtrCipher {
    key;
    keyBits;
    /**
     * Constructs an AES cipher instance using a shared secret.
     * The key is derived using SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     * @param keyBits - The AES key size in bits (128, 192, or 256).
     */
    constructor(sharedSecret, keyBits) {
        this.keyBits = keyBits;
        const hasher = createHash('sha3-256');
        // We follow [Section 4, Option 1.](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Cr2.pdf).
        // For our choice of hash function, we have:
        // - H_outputBits = 256
        // - max_H_inputBits = arbitrarily long, as SHA3 is built upon the sponge
        //   construction
        // - L = keyBits (128, 192, or 256).
        // Build the vector `counter || Z || FixedInfo` (we only have i = 1, since reps = 1).
        // the counter is a big-endian 4-byte unsigned integer
        const counter = [0, 0, 0, 1];
        for (let i = 0; i < sharedSecret.length; ++i) {
            counter.push(sharedSecret[i]);
        }
        // For the FixedInfo we simply take L. We represent L as a big-endian 2-byte
        // unsigned integer.
        counter.push(Math.floor(keyBits / 256));
        counter.push(keyBits % 256);
        hasher.update(new Uint8Array(counter));
        this.key = new Uint8Array(hasher.digest()).slice(0, KEY_BYTES[keyBits]);
    }
    /**
     * Encrypts the plaintext array in Counter (CTR) mode.
     * @param plaintext - The data to encrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The encrypted ciphertext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    encrypt(plaintext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = createCipheriv(`aes-${this.keyBits}-ctr`, this.key, paddedNonce);
        const ciphertext = Buffer.concat([cipher.update(plaintext), cipher.final()]);
        return new Uint8Array(ciphertext);
    }
    /**
     * Decrypts the ciphertext array in Counter (CTR) mode.
     * @param ciphertext - The data to decrypt.
     * @param nonce - An 8-byte nonce for CTR mode.
     * @returns The decrypted plaintext as a Uint8Array.
     * @throws Error if the nonce is not 8 bytes long.
     */
    decrypt(ciphertext, nonce) {
        if (nonce.length !== 8) {
            throw Error(`nonce must be of length 8 (found ${nonce.length})`);
        }
        const paddedNonce = Buffer.concat([nonce, Buffer.alloc(16 - nonce.length, 0)]);
        const cipher = createDecipheriv(`aes-${this.keyBits}-ctr`, this.key, paddedNonce);
        const decrypted = Buffer.concat([cipher.update(ciphertext), cipher.final()]);
        return new Uint8Array(decrypted);
    }
}

/**
 * AES-128 cipher in Counter (CTR) mode, using SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes128Cipher extends AesCtrCipher {
    /**
     * Constructs an AES-128 cipher instance using a shared secret.
     * The key is derived using SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        super(sharedSecret, 128);
    }
}

/**
 * AES-192 cipher in Counter (CTR) mode, using SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes192Cipher extends AesCtrCipher {
    /**
     * Constructs an AES-192 cipher instance using a shared secret.
     * The key is derived using SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        super(sharedSecret, 192);
    }
}

/**
 * AES-256 cipher in Counter (CTR) mode, using SHA3-256 to derive the key from a shared secret.
 * See: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf (Section 6.5) for details on CTR mode.
 */
class Aes256Cipher extends AesCtrCipher {
    /**
     * Constructs an AES-256 cipher instance using a shared secret.
     * The key is derived using SHA3-256.
     * @param sharedSecret - The shared secret to derive the AES key from.
     */
    constructor(sharedSecret) {
        super(sharedSecret, 256);
    }
}

class DataSize {
    isFull;
    size;
    index;
    constructor(index, size) {
        const isUndefined = size === undefined;
        this.isFull = isUndefined;
        this.size = isUndefined ? 0 : size;
        this.index = index;
    }
}
function sortDataSizes(arr) {
    return [...arr].sort((left, right) => {
        if (left.isFull !== right.isFull) {
            return left.isFull ? -1 : 1;
        }
        if (left.size !== right.size) {
            return right.size - left.size;
        }
        return left.index - right.index;
    });
}
class PackLocation {
    index;
    offset;
    constructor(index, offset) {
        this.index = index;
        this.offset = offset;
    }
}
class PackingState {
    maxSize;
    loads = [];
    nFull = 0;
    lastInsert = 0;
    constructor(maxSize) {
        this.maxSize = maxSize;
    }
    getCurrentLoad(index) {
        return this.loads[index] === undefined ? 0 : this.loads[index];
    }
    canFit(index, size) {
        return this.getCurrentLoad(index) + size <= this.maxSize;
    }
    chooseInsertLocation(size) {
        if (this.canFit(this.nFull, size)) {
            return this.nFull;
        }
        if (this.canFit(this.lastInsert, size)) {
            return this.lastInsert;
        }
        return this.lastInsert + 1;
    }
    insert(size) {
        if (size.isFull) {
            this.lastInsert = this.nFull;
            this.nFull++;
            return new PackLocation(this.lastInsert, 0);
        }
        const index = this.chooseInsertLocation(size.size);
        if (index >= this.loads.length) {
            this.loads.push(0);
        }
        const load = this.loads[index];
        this.loads[index] += size.size;
        return new PackLocation(index, load);
    }
}
function packing(maxSize, arr) {
    const sortedArr = sortDataSizes(arr);
    const inserts = [];
    const state = new PackingState(maxSize);
    sortedArr.forEach((value) => {
        const pack = state.insert(value);
        inserts.push([value.index, pack]);
    });
    const nPacks = state.nFull + state.loads.length;
    inserts.sort((left, right) => left[0] - right[0]);
    const res = inserts.map((arg) => arg[1]);
    return [nPacks, res];
}
const ARCIS_PACKING_SIZE = 214;
function arcisPacking(arr) {
    return packing(ARCIS_PACKING_SIZE, arr);
}

/** Length of a Pubkey in bytes (Solana public keys are 32 bytes) */
const PUBKEY_BYTE_LENGTH = 32;
/** Maximum value a Pubkey bigint can hold (2^256) */
const PUBKEY_MAX_VALUE = 1n << 256n;
var ArcisValueKind;
(function (ArcisValueKind) {
    ArcisValueKind[ArcisValueKind["Integer"] = 0] = "Integer";
    ArcisValueKind[ArcisValueKind["FullInteger"] = 1] = "FullInteger";
    ArcisValueKind[ArcisValueKind["Bool"] = 2] = "Bool";
    ArcisValueKind[ArcisValueKind["Float"] = 3] = "Float";
    ArcisValueKind[ArcisValueKind["Pubkey"] = 4] = "Pubkey";
})(ArcisValueKind || (ArcisValueKind = {}));
class IntegerInfo {
    signed;
    width;
    constructor(signed, width) {
        this.signed = signed;
        this.width = width;
    }
    static fromJson(json) {
        return new IntegerInfo(json.signed, BigInt(json.width));
    }
    minValue() {
        return this.signed ? -1n << (this.width - 1n) : 0n;
    }
    isWithinBounds(b) {
        const minVal = this.minValue();
        const maxVal = this.signed ? 1n << (this.width - 1n) : 1n << this.width;
        return minVal <= b && b < maxVal;
    }
    name() {
        return (this.signed ? "i" : "u") + this.width;
    }
}
class ArcisValueField {
    name;
    kind;
    info;
    constructor(name, kind, info) {
        this.name = name;
        this.kind = kind;
        this.info = info;
    }
    static fromJson(json) {
        const typedJson = json;
        const name = typedJson["name"];
        const rawType = typedJson["type"];
        let kind = ArcisValueKind.Integer;
        switch (rawType) {
            case "FullInteger":
                kind = ArcisValueKind.FullInteger;
                break;
            case "Bool":
                kind = ArcisValueKind.Bool;
                break;
            case "Float":
                kind = ArcisValueKind.Float;
                break;
            case "Pubkey":
                kind = ArcisValueKind.Pubkey;
                break;
        }
        if (kind === ArcisValueKind.Integer) {
            if (typeof rawType === "string") {
                throw new TypeError("Expected Integer type object with signed/width properties");
            }
            const info = IntegerInfo.fromJson(rawType.Integer);
            return new ArcisValueField(name, kind, info);
        }
        else {
            return new ArcisValueField(name, kind);
        }
    }
    toBigInt(arg) {
        if (this.kind === ArcisValueKind.Float) {
            if (typeof arg !== 'number') {
                throw new TypeError(`Field ${this.name} expected a number, got ${typeof arg}`);
            }
            return encodeAsRescueEncryptable(arg);
        }
        let value = arg;
        if (typeof value === 'number') {
            if (!Number.isInteger(value)) {
                throw new TypeError(`Field ${this.name}: expected integer, got float ${value}`);
            }
            if (!Number.isSafeInteger(value)) {
                throw new RangeError(`Field ${this.name}: ${value} exceeds safe integer range, use BigInt`);
            }
            value = BigInt(value);
        }
        switch (this.kind) {
            case ArcisValueKind.Bool:
                if (typeof value !== 'boolean') {
                    throw new TypeError(`Field ${this.name} expected a boolean, got ${typeof value}`);
                }
                return BigInt(value);
            case ArcisValueKind.FullInteger:
                if (typeof value !== 'bigint') {
                    throw new TypeError(`Field ${this.name} expected a bigint, got ${typeof value}`);
                }
                return value;
            case ArcisValueKind.Integer:
                if (typeof value !== 'bigint') {
                    throw new TypeError(`Field ${this.name} expected a bigint, got ${typeof value}`);
                }
                if (this.info === undefined) {
                    throw new TypeError(`Field ${this.name} is an integer, but signedness and width are unknown`);
                }
                if (!this.info.isWithinBounds(value)) {
                    const min = this.info.minValue();
                    const max = this.info.signed ? (1n << (this.info.width - 1n)) - 1n : (1n << this.info.width) - 1n;
                    throw new RangeError(`Field "${this.name}" (${this.info.name()}): value ${value} out of range [${min}, ${max}]`);
                }
                return value - this.info.minValue();
            case ArcisValueKind.Pubkey: {
                if (!(value instanceof Uint8Array)) {
                    throw new TypeError(`Field ${this.name} expected a Uint8Array, got ${typeof value}`);
                }
                if (value.length !== PUBKEY_BYTE_LENGTH) {
                    throw new RangeError(`Field ${this.name} expected ${PUBKEY_BYTE_LENGTH}-byte Uint8Array, got ${value.length} bytes`);
                }
                let pubkeyResult = 0n;
                for (let i = 0; i < PUBKEY_BYTE_LENGTH; i++) {
                    pubkeyResult |= BigInt(value[i]) << BigInt(i * 8);
                }
                return pubkeyResult;
            }
            default: {
                const _exhaustive = this.kind;
                throw new Error(`Unhandled ArcisValueKind: ${_exhaustive}`);
            }
        }
    }
    fromBigInt(arg) {
        switch (this.kind) {
            case ArcisValueKind.Bool:
                switch (arg) {
                    case 0n:
                        return false;
                    case 1n:
                        return true;
                    default:
                        throw new RangeError(`Field ${this.name}: Bool must be 0 or 1, got ${arg}`);
                }
            case ArcisValueKind.Float:
                return decodeRescueDecryptedToNumber(arg);
            case ArcisValueKind.FullInteger:
                return arg;
            case ArcisValueKind.Integer:
                if (this.info === undefined) {
                    throw new TypeError("Integer type without integer info");
                }
                return arg + this.info.minValue();
            case ArcisValueKind.Pubkey: {
                if (arg < 0n) {
                    throw new RangeError(`Field ${this.name}: Pubkey cannot be negative`);
                }
                if (arg >= PUBKEY_MAX_VALUE) {
                    throw new RangeError(`Field ${this.name}: Pubkey exceeds 256 bits`);
                }
                const pubkeyBytes = new Uint8Array(PUBKEY_BYTE_LENGTH);
                let remaining = arg;
                for (let i = 0; i < PUBKEY_BYTE_LENGTH; i++) {
                    pubkeyBytes[i] = Number(remaining & 0xffn);
                    remaining >>= 8n;
                }
                return pubkeyBytes;
            }
            default: {
                const _exhaustive = this.kind;
                throw new Error(`Unhandled ArcisValueKind: ${_exhaustive}`);
            }
        }
    }
    static fromFieldInfo(info) {
        const name = info.name;
        if (info.type === 'Bool') {
            return new ArcisValueField(name, ArcisValueKind.Bool);
        }
        if (info.type === 'FullInteger') {
            return new ArcisValueField(name, ArcisValueKind.FullInteger);
        }
        if (info.type === 'Float') {
            return new ArcisValueField(name, ArcisValueKind.Float);
        }
        if (info.type === 'Pubkey') {
            return new ArcisValueField(name, ArcisValueKind.Pubkey);
        }
        if (typeof info.type === 'object' && 'Integer' in info.type) {
            const intInfo = new IntegerInfo(info.type.Integer.signed, BigInt(info.type.Integer.width));
            return new ArcisValueField(name, ArcisValueKind.Integer, intInfo);
        }
        throw new TypeError(`Unknown field type for ${name}`);
    }
    toDataSize(index) {
        switch (this.kind) {
            case ArcisValueKind.Pubkey:
                return new DataSize(index);
            case ArcisValueKind.Integer:
                return new DataSize(index, Number(this.info?.width));
            case ArcisValueKind.FullInteger:
                return new DataSize(index);
            case ArcisValueKind.Bool:
                return new DataSize(index, 1);
            case ArcisValueKind.Float:
                return new DataSize(index);
        }
    }
}
class ArcisType {
    name;
    fields;
    constructor(name, fields) {
        this.name = name;
        this.fields = fields;
    }
    pack(rawData) {
        if (rawData.length !== this.fields.length) {
            throw new RangeError(`Expected ${this.fields.length} fields, got ${rawData.length}`);
        }
        const data = rawData.map((val, index) => this.fields[index].toBigInt(val));
        const dataSizes = this.fields.map((field, index) => field.toDataSize(index));
        const packing = arcisPacking(dataSizes);
        const plaintext = Array(packing[0]);
        plaintext.fill(0n);
        for (let idx = 0; idx < data.length; idx++) {
            const packLocation = packing[1][idx];
            plaintext[packLocation.index] += data[idx] << BigInt(packLocation.offset);
        }
        return plaintext;
    }
    unpack(packed) {
        const dataSizes = this.fields.map((field, index) => field.toDataSize(index));
        const packing = arcisPacking(dataSizes);
        if (packed.length < packing[0]) {
            throw new RangeError(`Expected at least ${packing[0]} packed elements, got ${packed.length}`);
        }
        const res = [];
        for (let idx = 0; idx < dataSizes.length; idx++) {
            const packLocation = packing[1][idx];
            const dataSize = dataSizes[idx];
            const val = dataSize.isFull ? packed[packLocation.index] : (packed[packLocation.index] >> BigInt(packLocation.offset)) % (1n << BigInt(dataSize.size));
            res.push(this.fields[idx].fromBigInt(val));
        }
        return res;
    }
    static fromJson(name, json) {
        const typedJson = json;
        const fields = typedJson.map(ArcisValueField.fromJson);
        return new ArcisType(name, fields);
    }
}

class ArcisModule {
    types;
    constructor(types) {
        this.types = types;
    }
    static fromJson(json) {
        const typedJson = json;
        const res = {};
        for (const key in typedJson) {
            res[key] = ArcisType.fromJson(key, typedJson[key]);
        }
        return new ArcisModule(res);
    }
    static loadFromFile(path) {
        const file = fs.readFileSync(path);
        const json = JSON.parse(file.toString());
        return ArcisModule.fromJson(json);
    }
}

function parseFieldName(name) {
    const match = name.match(/^(.+)\[(\d+)\]$/);
    if (match) {
        return { base: match[1], index: parseInt(match[2], 10) };
    }
    return { base: name, index: null };
}
function extractValue(data, fieldName) {
    const { base, index } = parseFieldName(fieldName);
    const value = data[base];
    if (index !== null) {
        if (!Array.isArray(value)) {
            throw new TypeError(`Field "${base}" should be an array`);
        }
        if (index >= value.length) {
            throw new RangeError(`Field "${base}[${index}]" out of bounds (array length: ${value.length})`);
        }
        return value[index];
    }
    return value;
}
function groupUnpackedValues(values, fieldNames) {
    const result = {};
    for (let i = 0; i < fieldNames.length; i++) {
        const { base, index } = parseFieldName(fieldNames[i]);
        const value = values[i];
        if (index !== null) {
            if (!result[base]) {
                result[base] = [];
            }
            result[base][index] = value;
        }
        else {
            result[base] = value;
        }
    }
    return result;
}
/**
 * Creates a type-safe packer from field definitions.
 * Use `as const` on the fields array for compile-time field name validation.
 * @param fields - Field definitions from generated code.
 * @param typeName - Type name for debugging.
 */
function createPacker(fields, typeName = 'Packer') {
    const arcisFields = fields.map(f => ArcisValueField.fromFieldInfo(f));
    const arcisType = new ArcisType(typeName, arcisFields);
    const fieldNames = fields.map(f => f.name);
    return {
        pack(data) {
            const arr = fieldNames.map(name => {
                const value = extractValue(data, name);
                if (value === undefined) {
                    throw new Error(`Missing required field: "${name}"`);
                }
                return value;
            });
            return arcisType.pack(arr);
        },
        unpack(packed) {
            const arr = arcisType.unpack(packed);
            return groupUnpackedValues(arr, fieldNames);
        }
    };
}

var address = "Arcj82pX7HxYKLR92qvgZUAd7vGS1k4hQvAFcPATFdEQ";
var metadata = {
	name: "arcium",
	version: "0.7.0",
	spec: "0.1.0",
	description: "The Arcium program"
};
var instructions = [
	{
		name: "activate_arx",
		discriminator: [
			15,
			203,
			48,
			186,
			243,
			85,
			60,
			115
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			}
		]
	},
	{
		name: "activate_cluster",
		discriminator: [
			228,
			170,
			10,
			172,
			246,
			96,
			63,
			154
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			}
		]
	},
	{
		name: "bump_epoch_cluster",
		discriminator: [
			172,
			203,
			90,
			207,
			128,
			221,
			229,
			246
		],
		accounts: [
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "callback_computation",
		discriminator: [
			11,
			224,
			42,
			236,
			0,
			154,
			74,
			163
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_def_offset"
						}
					]
				}
			},
			{
				name: "instructions_sysvar",
				address: "Sysvar1nstructions1111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "comp_def_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "execution_status",
				type: {
					defined: {
						name: "ExecutionStatus"
					}
				}
			},
			{
				name: "callback_transaction_index",
				type: "u8"
			}
		]
	},
	{
		name: "claim_computation_rent",
		discriminator: [
			215,
			218,
			1,
			166,
			81,
			218,
			16,
			151
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "claim_failure_append",
		discriminator: [
			92,
			52,
			184,
			203,
			76,
			221,
			128,
			69
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "failure_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								97,
								105,
								108,
								117,
								114,
								101,
								67,
								108,
								97,
								105,
								109,
								65,
								99,
								99,
								111,
								117,
								110,
								116,
								72,
								101,
								97,
								100,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "chunk",
				type: "bytes"
			},
			{
				name: "failure_claim_offset",
				type: "u32"
			}
		]
	},
	{
		name: "claim_failure_finalize",
		discriminator: [
			192,
			133,
			215,
			19,
			76,
			107,
			111,
			217
		],
		accounts: [
			{
				name: "signer",
				signer: true
			},
			{
				name: "failure_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								97,
								105,
								108,
								117,
								114,
								101,
								67,
								108,
								97,
								105,
								109,
								65,
								99,
								99,
								111,
								117,
								110,
								116,
								72,
								101,
								97,
								100,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "claim_failure_init",
		discriminator: [
			204,
			106,
			245,
			73,
			212,
			136,
			61,
			99
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "comp_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						},
						{
							kind: "account",
							path: "comp_acc.computation_definition_offset",
							account: "ComputationAccount"
						}
					]
				}
			},
			{
				name: "failure_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								97,
								105,
								108,
								117,
								114,
								101,
								67,
								108,
								97,
								105,
								109,
								65,
								99,
								99,
								111,
								117,
								110,
								116,
								72,
								101,
								97,
								100,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "output_len_bytes",
				type: "u32"
			}
		]
	},
	{
		name: "claim_node_fees",
		discriminator: [
			68,
			13,
			185,
			34,
			151,
			76,
			194,
			43
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "recipient",
				writable: true
			},
			{
				name: "cluster",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "node_offset",
				type: "u32"
			}
		]
	},
	{
		name: "close_key_recovery",
		docs: [
			"Closes all recovery-related accounts."
		],
		discriminator: [
			249,
			127,
			56,
			116,
			125,
			136,
			84,
			184
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "backup_mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_backup_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "key_recovery_finalize_comp_def",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "const",
							value: [
								3,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "deactivate_arx",
		discriminator: [
			117,
			244,
			137,
			148,
			25,
			190,
			175,
			164
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "cluster_acc",
				optional: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "arx_node_acc"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			}
		]
	},
	{
		name: "deactivate_cluster",
		discriminator: [
			13,
			42,
			182,
			159,
			184,
			10,
			212,
			178
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "deactivation_epoch",
				type: {
					defined: {
						name: "Epoch"
					}
				}
			}
		]
	},
	{
		name: "dummy_instruction",
		docs: [
			"Only present so the mempool and execpool accounts are actually included in the idl, since we",
			"don't explicitly declare them in the accounts section of the other instructions."
		],
		discriminator: [
			57,
			4,
			200,
			151,
			58,
			19,
			120,
			9
		],
		accounts: [
			{
				name: "tiny_mempool"
			},
			{
				name: "tiny_execpool"
			},
			{
				name: "small_mempool"
			},
			{
				name: "small_execpool"
			},
			{
				name: "medium_mempool"
			},
			{
				name: "medium_execpool"
			},
			{
				name: "large_mempool"
			},
			{
				name: "large_execpool"
			}
		],
		args: [
		]
	},
	{
		name: "embiggen_raw_circuit_acc",
		discriminator: [
			92,
			195,
			192,
			21,
			193,
			242,
			135,
			194
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "_raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			}
		]
	},
	{
		name: "extend_recovery_keyshares",
		discriminator: [
			236,
			31,
			169,
			50,
			185,
			38,
			47,
			187
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "_mxe_program",
				type: "pubkey"
			},
			{
				name: "keyshares_offset",
				type: "u32"
			},
			{
				name: "keyshares",
				type: {
					vec: {
						array: [
							{
								array: [
									"u8",
									32
								]
							},
							5
						]
					}
				}
			}
		]
	},
	{
		name: "finalize_computation_definition",
		discriminator: [
			174,
			66,
			159,
			51,
			199,
			243,
			219,
			38
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				docs: [
					"At least the first raw circuit account must exist before finalizing"
				],
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "const",
							value: [
								0
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "finalize_key_recovery_callback",
		docs: [
			"Callback for key_recovery_finalize computation."
		],
		discriminator: [
			143,
			63,
			33,
			26,
			66,
			235,
			94,
			31
		],
		accounts: [
			{
				name: "signer",
				signer: true
			},
			{
				name: "original_mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "backup_mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_backup_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "const",
							value: [
								3,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			},
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "execution_status",
				type: {
					defined: {
						name: "ExecutionStatus"
					}
				}
			},
			{
				name: "callback_transaction_index",
				type: "u8"
			},
			{
				name: "bls_sig",
				type: {
					option: {
						array: [
							"u8",
							64
						]
					}
				}
			}
		]
	},
	{
		name: "finalize_key_recovery_execution",
		docs: [
			"Finalizes the key recovery execution after threshold is met and queues the computation."
		],
		discriminator: [
			211,
			40,
			223,
			121,
			15,
			169,
			2,
			59
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "payer",
				writable: true,
				signer: true
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "backup_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_backup_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "key_recovery_finalize_comp_def",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "const",
							value: [
								3,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "key_recovery_finalize_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "account",
							path: "mxe_recovery_account"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			},
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "finalize_key_recovery_shares_upload",
		discriminator: [
			205,
			57,
			149,
			12,
			12,
			176,
			188,
			74
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						},
						{
							kind: "arg",
							path: "_computation_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "_mxe_program",
				type: "pubkey"
			},
			{
				name: "computation_offset",
				type: "u64"
			}
		]
	},
	{
		name: "finalize_mxe_keys",
		discriminator: [
			108,
			137,
			125,
			95,
			202,
			237,
			190,
			158
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "_mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "increase_mempool_size",
		discriminator: [
			19,
			165,
			166,
			25,
			174,
			122,
			166,
			250
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "init",
		discriminator: [
			220,
			59,
			207,
			236,
			108,
			250,
			47,
			100
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "fee_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "start_epoch_timestamp",
				type: {
					defined: {
						name: "Timestamp"
					}
				}
			}
		]
	},
	{
		name: "init_arx_node",
		discriminator: [
			55,
			177,
			212,
			125,
			72,
			118,
			148,
			232
		],
		accounts: [
			{
				name: "operator_signer",
				writable: true,
				signer: true
			},
			{
				name: "operator_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								79,
								112,
								101,
								114,
								97,
								116,
								111,
								114
							]
						},
						{
							kind: "account",
							path: "operator_signer"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "config",
				type: {
					defined: {
						name: "ArxNodeConfig"
					}
				}
			},
			{
				name: "cu_capacity_claim",
				type: "u64"
			},
			{
				name: "bls_pubkey",
				type: {
					defined: {
						name: "BN254G2BLSPublicKey"
					}
				}
			},
			{
				name: "metadata",
				type: {
					defined: {
						name: "NodeMetadata"
					}
				}
			},
			{
				name: "x25519_pubkey",
				type: {
					array: [
						"u8",
						32
					]
				}
			}
		]
	},
	{
		name: "init_cluster",
		discriminator: [
			144,
			230,
			5,
			18,
			93,
			71,
			133,
			187
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "authority"
			},
			{
				name: "mempool",
				docs: [
					"function"
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "execpool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			},
			{
				name: "pool_account",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "mempool_size",
				type: {
					defined: {
						name: "MempoolSize"
					}
				}
			},
			{
				name: "cluster_size",
				type: "u16"
			},
			{
				name: "cu_price",
				type: "u64"
			},
			{
				name: "td_info",
				type: {
					option: {
						defined: {
							name: "NodeMetadata"
						}
					}
				}
			}
		]
	},
	{
		name: "init_computation_definition",
		docs: [
			"Initializes a computation definition."
		],
		discriminator: [
			45,
			185,
			155,
			17,
			97,
			77,
			230,
			73
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "address_lookup_table",
				docs: [
					"Seeds are checked in the CPI to LUT program, so no need to check them here."
				],
				writable: true
			},
			{
				name: "lut_program",
				address: "AddressLookupTab1e1111111111111111111111111"
			},
			{
				name: "comp_def_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "system_program",
				docs: [
					"System program account."
				],
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "computation_definition",
				type: {
					defined: {
						name: "ComputationDefinitionMeta"
					}
				}
			},
			{
				name: "circuit_source_override",
				type: {
					option: {
						defined: {
							name: "CircuitSource"
						}
					}
				}
			},
			{
				name: "cu_amount",
				type: "u64"
			},
			{
				name: "finalization_authority",
				type: {
					option: "pubkey"
				}
			}
		]
	},
	{
		name: "init_key_recovery_execution_part1",
		docs: [
			"Part 1 of key recovery execution initialization.",
			"Creates the MxeRecoveryAccount with partial size due to Solana's 10KB limit.",
			"Call init_key_recovery_execution_part2 afterwards."
		],
		discriminator: [
			73,
			228,
			114,
			224,
			181,
			108,
			251,
			224
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "payer",
				writable: true,
				signer: true
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				docs: [
					"Full allocation happens in init_key_recovery_execution_part2."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "init_key_recovery_execution_part2",
		docs: [
			"Part 2 of key recovery execution initialization.",
			"Finishes allocating MxeRecoveryAccount and creates the computation definition."
		],
		discriminator: [
			181,
			38,
			231,
			178,
			21,
			239,
			196,
			158
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "payer",
				writable: true,
				signer: true
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "backup_mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_backup_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "key_recovery_finalize_comp_def",
				docs: [
					"The computation definition account for MxeKeyRecoveryFinalize (on backup MXE)"
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "const",
							value: [
								3,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "init_mxe_part1",
		docs: [
			"Initializes a MPC Execution Environment (part 1).",
			"Due to Solana's 10KB per-instruction allocation limit, this only partially",
			"allocates recovery_cluster_acc. Call init_mxe_part2 afterwards to finish",
			"allocation and add keygen to mempool."
		],
		discriminator: [
			134,
			126,
			69,
			42,
			180,
			144,
			202,
			165
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "recovery_cluster_acc",
				docs: [
					"Full allocation happens in init_mxe_part2."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_program",
				docs: [
					"constraint in tests because setting it would require us to deploy a program each time."
				]
			},
			{
				name: "system_program",
				docs: [
					"System program account."
				],
				address: "11111111111111111111111111111111"
			}
		],
		args: [
		]
	},
	{
		name: "init_mxe_part2",
		docs: [
			"Finishes MXE initialization (part 2).",
			"Reallocates recovery_cluster_acc to full size, initializes recovery_peers,",
			"and adds the keygen computation to the mempool."
		],
		discriminator: [
			70,
			121,
			251,
			59,
			255,
			152,
			202,
			136
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "cluster",
				docs: [
					"Cluster to add to the MXE."
				],
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				docs: [
					"MXE account to initialize."
				],
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe_keygen_computation_definition",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						},
						{
							kind: "const",
							value: [
								1,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "mxe_keygen_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "arg",
							path: "keygen_offset"
						}
					]
				}
			},
			{
				name: "key_recovery_init_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "arg",
							path: "key_recovery_init_offset"
						}
					]
				}
			},
			{
				name: "mxe_authority",
				optional: true
			},
			{
				name: "mxe_program",
				docs: [
					"constraint in tests because setting it would require us to deploy a program each time."
				]
			},
			{
				name: "program_data",
				docs: [
					"The seeds constraint is only applied in non-testing builds."
				],
				pda: {
					seeds: [
						{
							kind: "account",
							path: "mxe_program"
						}
					],
					program: {
						kind: "const",
						value: [
							2,
							168,
							246,
							145,
							78,
							136,
							161,
							176,
							226,
							16,
							21,
							62,
							247,
							99,
							174,
							43,
							0,
							194,
							185,
							61,
							22,
							193,
							36,
							210,
							192,
							83,
							122,
							16,
							4,
							128,
							0,
							0
						]
					}
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "address_lookup_table",
				docs: [
					"Seeds are checked in the CPI to LUT program, so no need to check them here."
				],
				writable: true
			},
			{
				name: "lut_program",
				address: "AddressLookupTab1e1111111111111111111111111"
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "recovery_peers",
				type: {
					array: [
						"u32",
						100
					]
				}
			},
			{
				name: "keygen_offset",
				type: "u64"
			},
			{
				name: "key_recovery_init_offset",
				type: "u64"
			},
			{
				name: "recent_offset",
				type: "u64"
			}
		]
	},
	{
		name: "init_operator",
		discriminator: [
			132,
			210,
			12,
			91,
			159,
			94,
			35,
			54
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "operator_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								79,
								112,
								101,
								114,
								97,
								116,
								111,
								114
							]
						},
						{
							kind: "account",
							path: "signer"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "meta",
				type: {
					defined: {
						name: "OperatorMeta"
					}
				}
			}
		]
	},
	{
		name: "init_raw_circuit_acc",
		discriminator: [
			16,
			228,
			193,
			228,
			93,
			231,
			58,
			4
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "_raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			}
		]
	},
	{
		name: "join_cluster",
		discriminator: [
			150,
			167,
			124,
			239,
			108,
			128,
			31,
			162
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "node_bump",
				type: "u32"
			},
			{
				name: "join",
				type: "bool"
			}
		]
	},
	{
		name: "propose_fee",
		discriminator: [
			103,
			204,
			172,
			134,
			248,
			252,
			27,
			170
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "proposed_fee",
				type: "u64"
			}
		]
	},
	{
		name: "propose_join_cluster",
		discriminator: [
			148,
			228,
			222,
			211,
			161,
			128,
			118,
			175
		],
		accounts: [
			{
				name: "cluster_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "node_bump",
				type: "u32"
			}
		]
	},
	{
		name: "queue_computation",
		docs: [
			"Queues a computation.",
			"cu_price_micro: The priority price of a CU, in micro-lamports. Used",
			"to calculate the priority fee and rounded down."
		],
		discriminator: [
			1,
			149,
			103,
			13,
			102,
			227,
			93,
			164
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "sign_seed",
				docs: [
					"This is ok-ish though, as we're just reading the bump to verify the PDA."
				],
				signer: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								99,
								105,
								117,
								109,
								83,
								105,
								103,
								110,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					],
					program: {
						kind: "arg",
						path: "_mxe_program"
					}
				}
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						},
						{
							kind: "arg",
							path: "computation_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "computation_definition_offset"
						}
					]
				}
			},
			{
				name: "cluster",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "computation_definition_offset",
				type: "u32"
			},
			{
				name: "args",
				type: {
					defined: {
						name: "ArgumentList"
					}
				}
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "custom_callback_instructions",
				type: {
					vec: {
						defined: {
							name: "CallbackInstruction"
						}
					}
				}
			},
			{
				name: "callback_transactions_required",
				type: "u8"
			},
			{
				name: "output_delivery_fee",
				type: "u64"
			},
			{
				name: "cu_price_micro",
				type: "u64"
			}
		]
	},
	{
		name: "queue_key_recovery_init",
		docs: [
			"Queues the key recovery init computation for the MXE.",
			"Can only be called once after MXE keys are set."
		],
		discriminator: [
			76,
			132,
			32,
			81,
			11,
			163,
			98,
			82
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "key_recovery_init_computation_definition",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						},
						{
							kind: "const",
							value: [
								2,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "key_recovery_init_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "account",
							path: "mxe.key_recovery_init_offset",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "mxe_program"
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "reclaim_expired_computation_fee",
		docs: [
			"Reclaim fees for an expired computation that was never executed."
		],
		discriminator: [
			146,
			230,
			72,
			249,
			217,
			144,
			70,
			33
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "comp_offset"
						}
					]
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "reclaim_failure_rent_idempotent",
		discriminator: [
			138,
			13,
			253,
			191,
			226,
			239,
			246,
			10
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "recipient",
				docs: [
					"failure PDA"
				],
				writable: true
			},
			{
				name: "failure_acc",
				docs: [
					"the checks and close by hand in the instruction handler."
				],
				writable: true
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u64"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "recover_mxe",
		docs: [
			"Sets an MXE to the Recovery state, enabling the recovery process to begin."
		],
		discriminator: [
			65,
			99,
			9,
			69,
			97,
			38,
			105,
			253
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_program"
			}
		],
		args: [
			{
				name: "mxe_program",
				type: "pubkey"
			}
		]
	},
	{
		name: "requeue_key_recovery_finalize",
		docs: [
			"Re-queues the key_recovery_finalize computation after a failed execution."
		],
		discriminator: [
			131,
			109,
			226,
			183,
			90,
			203,
			17,
			191
		],
		accounts: [
			{
				name: "authority",
				writable: true,
				signer: true
			},
			{
				name: "payer",
				writable: true,
				signer: true
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "backup_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_backup_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "key_recovery_finalize_comp_def",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "const",
							value: [
								3,
								0,
								0,
								0
							]
						}
					]
				}
			},
			{
				name: "previous_computation",
				docs: [
					"The previous failed computation account"
				],
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "account",
							path: "mxe_recovery_account"
						}
					]
				}
			},
			{
				name: "new_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "arg",
							path: "new_key_recovery_finalize_offset"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "pool_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								70,
								101,
								101,
								80,
								111,
								111,
								108
							]
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			},
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "new_key_recovery_finalize_offset",
				type: "u64"
			}
		]
	},
	{
		name: "requeue_mxe_keygen",
		docs: [
			"Re-queues the MXE keygen computation if it has expired from the mempool.",
			"This allows retrying the keygen if it wasn't processed in time."
		],
		discriminator: [
			90,
			98,
			117,
			181,
			88,
			71,
			135,
			30
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "executing_pool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								69,
								120,
								101,
								99,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mempool",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								101,
								109,
								112,
								111,
								111,
								108
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "cluster",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe_keygen_computation",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						},
						{
							kind: "account",
							path: "mxe.keygen_offset",
							account: "MXEAccount"
						}
					]
				}
			},
			{
				name: "mxe_program"
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "set_arx_node_config",
		discriminator: [
			163,
			75,
			176,
			148,
			145,
			196,
			238,
			234
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "config",
				type: {
					defined: {
						name: "ArxNodeConfig"
					}
				}
			}
		]
	},
	{
		name: "set_arx_node_metadata",
		discriminator: [
			176,
			88,
			44,
			90,
			127,
			151,
			62,
			80
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "arx_node_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "_node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "meta",
				type: {
					defined: {
						name: "NodeMetadata"
					}
				}
			}
		]
	},
	{
		name: "set_cluster",
		discriminator: [
			140,
			96,
			38,
			83,
			225,
			128,
			25,
			176
		],
		accounts: [
			{
				name: "signer",
				docs: [
					"Signer of the transaction."
				],
				writable: true,
				signer: true
			},
			{
				name: "mxe",
				docs: [
					"MXE account to set the cluster for."
				],
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "mxe_program"
						}
					]
				}
			},
			{
				name: "cluster",
				docs: [
					"Cluster to set for the MXE."
				],
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "mxe_program"
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			}
		]
	},
	{
		name: "set_cluster_authority",
		discriminator: [
			94,
			172,
			32,
			75,
			38,
			40,
			31,
			106
		],
		accounts: [
			{
				name: "current_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_id"
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "new_authority",
				type: {
					option: "pubkey"
				}
			}
		]
	},
	{
		name: "set_mxe_keys",
		discriminator: [
			156,
			205,
			125,
			215,
			134,
			88,
			62,
			144
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "_mxe_program",
				type: "pubkey"
			},
			{
				name: "mxe_x25519_pubkey",
				type: {
					array: [
						"u8",
						32
					]
				}
			},
			{
				name: "mxe_ed25519_verifying_key",
				type: {
					array: [
						"u8",
						32
					]
				}
			},
			{
				name: "mxe_elgamal_pubkey",
				type: {
					array: [
						"u8",
						32
					]
				}
			},
			{
				name: "mxe_pubkey_validity_proof",
				type: {
					array: [
						"u8",
						64
					]
				}
			}
		]
	},
	{
		name: "set_mxe_recovery_keys_init",
		discriminator: [
			49,
			89,
			116,
			64,
			81,
			250,
			112,
			64
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "mxe",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						}
					]
				}
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "account",
							path: "mxe.cluster.ok_or(ArciumError :: ClusterNotSet) ? ",
							account: "MXEAccount"
						}
					]
				}
			}
		],
		args: [
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "_mxe_program",
				type: "pubkey"
			},
			{
				name: "nonce",
				type: {
					array: [
						"u8",
						16
					]
				}
			},
			{
				name: "encrypted_mxe_keys",
				type: {
					array: [
						{
							array: [
								"u8",
								32
							]
						},
						13
					]
				}
			},
			{
				name: "key_material_hash",
				type: {
					array: [
						"u8",
						32
					]
				}
			},
			{
				name: "bls_sig",
				type: {
					array: [
						"u8",
						64
					]
				}
			}
		]
	},
	{
		name: "submit_aggregated_bls_pubkey",
		discriminator: [
			192,
			135,
			47,
			120,
			63,
			18,
			232,
			164
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_id",
				type: "u32"
			},
			{
				name: "node_bump",
				type: "u32"
			},
			{
				name: "aggregated_bls_pubkey",
				type: {
					defined: {
						name: "BN254G2BLSPublicKey"
					}
				}
			}
		]
	},
	{
		name: "submit_key_recovery_share",
		docs: [
			"Submits a recovery share from a recovery peer.",
			"Each share contains RESCUE_KEY_COUNT (5) field elements of 32 bytes each."
		],
		discriminator: [
			108,
			74,
			123,
			253,
			76,
			98,
			190,
			164
		],
		accounts: [
			{
				name: "node_signer",
				writable: true,
				signer: true
			},
			{
				name: "node",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "original_mxe",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								88,
								69,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "recovery_cluster_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								67,
								108,
								117,
								115,
								116,
								101,
								114,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_original_mxe_program"
						}
					]
				}
			},
			{
				name: "mxe_recovery_account",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								77,
								120,
								101,
								82,
								101,
								99,
								111,
								118,
								101,
								114,
								121,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "account",
							path: "backup_mxe_program"
						},
						{
							kind: "account",
							path: "original_mxe_program"
						}
					]
				}
			},
			{
				name: "original_mxe_program"
			},
			{
				name: "backup_mxe_program"
			}
		],
		args: [
			{
				name: "original_mxe_program",
				type: "pubkey"
			},
			{
				name: "backup_mxe_program",
				type: "pubkey"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "peer_index",
				type: "u32"
			},
			{
				name: "share",
				type: {
					array: [
						{
							array: [
								"u8",
								32
							]
						},
						5
					]
				}
			}
		]
	},
	{
		name: "update_current_epoch_idempotent",
		discriminator: [
			47,
			73,
			68,
			127,
			116,
			74,
			89,
			62
		],
		accounts: [
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
		]
	},
	{
		name: "upload_circuit",
		discriminator: [
			86,
			238,
			214,
			111,
			30,
			23,
			168,
			100
		],
		accounts: [
			{
				name: "signer",
				writable: true,
				signer: true
			},
			{
				name: "comp_def_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						},
						{
							kind: "arg",
							path: "_mxe_program"
						},
						{
							kind: "arg",
							path: "_comp_offset"
						}
					]
				}
			},
			{
				name: "comp_def_raw",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								111,
								109,
								112,
								117,
								116,
								97,
								116,
								105,
								111,
								110,
								68,
								101,
								102,
								105,
								110,
								105,
								116,
								105,
								111,
								110,
								82,
								97,
								119
							]
						},
						{
							kind: "account",
							path: "comp_def_acc"
						},
						{
							kind: "arg",
							path: "raw_circuit_index"
						}
					]
				}
			},
			{
				name: "system_program",
				address: "11111111111111111111111111111111"
			}
		],
		args: [
			{
				name: "comp_offset",
				type: "u32"
			},
			{
				name: "mxe_program",
				type: "pubkey"
			},
			{
				name: "raw_circuit_index",
				type: "u8"
			},
			{
				name: "upload_data",
				type: {
					array: [
						"u8",
						814
					]
				}
			},
			{
				name: "offset",
				type: "u32"
			}
		]
	},
	{
		name: "vote_fee",
		discriminator: [
			39,
			118,
			79,
			185,
			118,
			12,
			71,
			84
		],
		accounts: [
			{
				name: "node_authority",
				writable: true,
				signer: true
			},
			{
				name: "cluster_acc",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								117,
								115,
								116,
								101,
								114
							]
						},
						{
							kind: "arg",
							path: "_cluster_offset"
						}
					]
				}
			},
			{
				name: "arx_node_acc",
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								65,
								114,
								120,
								78,
								111,
								100,
								101
							]
						},
						{
							kind: "arg",
							path: "node_offset"
						}
					]
				}
			},
			{
				name: "clock",
				writable: true,
				pda: {
					seeds: [
						{
							kind: "const",
							value: [
								67,
								108,
								111,
								99,
								107,
								65,
								99,
								99,
								111,
								117,
								110,
								116
							]
						}
					]
				}
			}
		],
		args: [
			{
				name: "cluster_offset",
				type: "u32"
			},
			{
				name: "node_offset",
				type: "u32"
			},
			{
				name: "fee_vote",
				type: "u64"
			}
		]
	}
];
var accounts = [
	{
		name: "ArxNode",
		discriminator: [
			2,
			207,
			122,
			223,
			93,
			97,
			231,
			199
		]
	},
	{
		name: "ClockAccount",
		discriminator: [
			152,
			171,
			158,
			195,
			75,
			61,
			51,
			8
		]
	},
	{
		name: "Cluster",
		discriminator: [
			236,
			225,
			118,
			228,
			173,
			106,
			18,
			60
		]
	},
	{
		name: "ComputationAccount",
		discriminator: [
			136,
			34,
			167,
			71,
			41,
			174,
			103,
			77
		]
	},
	{
		name: "ComputationDefinitionAccount",
		discriminator: [
			245,
			176,
			217,
			221,
			253,
			104,
			172,
			200
		]
	},
	{
		name: "ComputationDefinitionRaw",
		discriminator: [
			226,
			70,
			57,
			224,
			38,
			233,
			59,
			136
		]
	},
	{
		name: "FailureClaimAccountHeader",
		discriminator: [
			132,
			11,
			106,
			171,
			253,
			138,
			56,
			78
		]
	},
	{
		name: "FeePool",
		discriminator: [
			172,
			38,
			77,
			146,
			148,
			5,
			51,
			242
		]
	},
	{
		name: "LargeExecPool",
		discriminator: [
			147,
			145,
			148,
			170,
			30,
			13,
			43,
			216
		]
	},
	{
		name: "LargeMempool",
		discriminator: [
			16,
			168,
			90,
			235,
			249,
			207,
			73,
			223
		]
	},
	{
		name: "MXEAccount",
		discriminator: [
			103,
			26,
			85,
			250,
			179,
			159,
			17,
			117
		]
	},
	{
		name: "MediumExecPool",
		discriminator: [
			97,
			117,
			128,
			202,
			213,
			76,
			5,
			163
		]
	},
	{
		name: "MediumMempool",
		discriminator: [
			10,
			249,
			58,
			39,
			255,
			231,
			199,
			168
		]
	},
	{
		name: "MxeRecoveryAccount",
		discriminator: [
			35,
			240,
			187,
			131,
			211,
			114,
			166,
			11
		]
	},
	{
		name: "Operator",
		discriminator: [
			219,
			31,
			188,
			145,
			69,
			139,
			204,
			117
		]
	},
	{
		name: "RecoveryClusterAccount",
		discriminator: [
			116,
			60,
			120,
			184,
			194,
			209,
			87,
			183
		]
	},
	{
		name: "SmallExecPool",
		discriminator: [
			37,
			147,
			249,
			253,
			217,
			136,
			3,
			87
		]
	},
	{
		name: "SmallMempool",
		discriminator: [
			123,
			153,
			151,
			118,
			126,
			71,
			73,
			92
		]
	},
	{
		name: "TinyExecPool",
		discriminator: [
			80,
			245,
			5,
			90,
			154,
			189,
			190,
			172
		]
	},
	{
		name: "TinyMempool",
		discriminator: [
			176,
			33,
			67,
			108,
			73,
			135,
			110,
			166
		]
	}
];
var events = [
	{
		name: "CallbackComputationEvent",
		discriminator: [
			155,
			213,
			238,
			159,
			240,
			76,
			167,
			19
		]
	},
	{
		name: "ClaimFailureEvent",
		discriminator: [
			143,
			97,
			229,
			166,
			72,
			218,
			87,
			145
		]
	},
	{
		name: "FinalizeComputationEvent",
		discriminator: [
			27,
			75,
			117,
			221,
			191,
			213,
			253,
			249
		]
	},
	{
		name: "FinalizeFailureDataEvent",
		discriminator: [
			132,
			26,
			138,
			201,
			214,
			29,
			244,
			167
		]
	},
	{
		name: "InitComputationEvent",
		discriminator: [
			17,
			51,
			124,
			226,
			70,
			97,
			58,
			186
		]
	},
	{
		name: "KeyRecoveryEvent",
		discriminator: [
			83,
			147,
			226,
			153,
			39,
			242,
			109,
			254
		]
	},
	{
		name: "QueueComputationEvent",
		discriminator: [
			118,
			53,
			33,
			169,
			32,
			14,
			197,
			147
		]
	}
];
var errors = [
	{
		code: 6000,
		name: "InvalidAuthority",
		msg: "The given authority is invalid"
	},
	{
		code: 6001,
		name: "MxeKeysAlreadySet",
		msg: "The MXE keys are already set, i.e. all the nodes of the MXE cluster already agreed on the MXE keys"
	},
	{
		code: 6002,
		name: "MxeKeysNotSet",
		msg: "The MXE keys are not set, i.e. not all the nodes of the MXE cluster agreed on the MXE keys"
	},
	{
		code: 6003,
		name: "InvalidMXE",
		msg: "An invalid MXE account has been supplied"
	},
	{
		code: 6004,
		name: "ClusterAlreadySet",
		msg: "The cluster is already set"
	},
	{
		code: 6005,
		name: "ClusterNotSet",
		msg: "The cluster is not set"
	},
	{
		code: 6006,
		name: "InvalidCluster",
		msg: "An invalid cluster account has been supplied"
	},
	{
		code: 6007,
		name: "InvalidComputationDefinition",
		msg: "An invalid computation definition account has been supplied"
	},
	{
		code: 6008,
		name: "CantFindMempoolID",
		msg: "Couldn't find a mempool ID for the computation"
	},
	{
		code: 6100,
		name: "InvalidMempoolDiscriminator",
		msg: "Mempool discriminator is invalid"
	},
	{
		code: 6101,
		name: "InvalidMempoolSize",
		msg: "Mempool size is invalid"
	},
	{
		code: 6102,
		name: "InvalidExecpoolDiscriminator",
		msg: "Execpool discriminator is invalid"
	},
	{
		code: 6103,
		name: "MaxParallelismReached",
		msg: "Max parallelism reached"
	},
	{
		code: 6200,
		name: "InvalidComputationOffset",
		msg: "Computation offset is invalid"
	},
	{
		code: 6201,
		name: "InvalidCallbackAccs",
		msg: "Callback accounts are invalid"
	},
	{
		code: 6202,
		name: "InvalidCallbackAccsLen",
		msg: "Callback accounts length is invalid"
	},
	{
		code: 6203,
		name: "AlreadyInitializedComputation",
		msg: "The computation is already initialized"
	},
	{
		code: 6204,
		name: "AlreadyCallbackedComputation",
		msg: "Callback computation already called"
	},
	{
		code: 6205,
		name: "InvalidCallbackTx",
		msg: "Callback tx is invalid"
	},
	{
		code: 6206,
		name: "InvalidComputationStatus",
		msg: "Computation status is invalid"
	},
	{
		code: 6207,
		name: "InvalidComputation",
		msg: "Computation is invalid"
	},
	{
		code: 6208,
		name: "InvalidComputationAuthority",
		msg: "Computation authority is invalid"
	},
	{
		code: 6209,
		name: "InvalidCallbackInstructions",
		msg: "Callback instructions are invalid"
	},
	{
		code: 6210,
		name: "ComputationNotExpired",
		msg: "Computation has not expired from mempool yet"
	},
	{
		code: 6211,
		name: "InvalidCallbackIndex",
		msg: "Invalid callback transaction index"
	},
	{
		code: 6212,
		name: "MultiTxCallbacksDisabled",
		msg: "Multi-transaction callbacks disabled"
	},
	{
		code: 6300,
		name: "ComputationDefinitionNotCompleted",
		msg: "Computation definition is not completed"
	},
	{
		code: 6301,
		name: "InvalidArguments",
		msg: "Arguments supplied are invalid"
	},
	{
		code: 6302,
		name: "InvalidCircuitSource",
		msg: "Circuit source is invalid"
	},
	{
		code: 6303,
		name: "ComputationDefinitionAlreadyCompleted",
		msg: "Computation definition already completed"
	},
	{
		code: 6304,
		name: "InvalidCUAmount",
		msg: "CU amount exceeds maximum limit"
	},
	{
		code: 6305,
		name: "InvalidOffset",
		msg: "Offset is invalid"
	},
	{
		code: 6400,
		name: "InvalidNode",
		msg: "Node is invalid"
	},
	{
		code: 6401,
		name: "MaxClusterMembershipReached",
		msg: "Maximum number of nodes in the cluster has been reached"
	},
	{
		code: 6402,
		name: "NodeAlreadyExists",
		msg: "The node already exists in the cluster"
	},
	{
		code: 6403,
		name: "InvalidNodeAuthority",
		msg: "Node authority is invalid"
	},
	{
		code: 6404,
		name: "NodeNotInactive",
		msg: "Node is not inactive"
	},
	{
		code: 6405,
		name: "NodeNotActive",
		msg: "Node is not active"
	},
	{
		code: 6406,
		name: "InvalidClusterMembership",
		msg: "Cluster membership is invalid"
	},
	{
		code: 6407,
		name: "NodeInActiveCluster",
		msg: "Node is in an active cluster"
	},
	{
		code: 6408,
		name: "InvalidNodeConfig",
		msg: "Node config is invalid"
	},
	{
		code: 6409,
		name: "UnauthorizedNodeCreation",
		msg: "Unauthorized to create node on mainnet"
	},
	{
		code: 6410,
		name: "InvalidNodeOffset",
		msg: "Node offset is invalid"
	},
	{
		code: 6500,
		name: "ClusterFull",
		msg: "Cluster is full"
	},
	{
		code: 6501,
		name: "InvalidDeactivationEpoch",
		msg: "Cluster deactivation epoch is invalid"
	},
	{
		code: 6502,
		name: "InvalidMaxSize",
		msg: "Cluster maximum size is invalid"
	},
	{
		code: 6503,
		name: "InvalidClusterAuthority",
		msg: "Cluster authority is invalid"
	},
	{
		code: 6504,
		name: "InvalidFeeProposal",
		msg: "Cluster fee proposal is invalid"
	},
	{
		code: 6505,
		name: "InvalidClusterState",
		msg: "Cluster state is invalid"
	},
	{
		code: 6506,
		name: "InvalidVote",
		msg: "Cluster vote is invalid"
	},
	{
		code: 6507,
		name: "ClusterNotReady",
		msg: "Cluster is not ready"
	},
	{
		code: 6600,
		name: "SerializationFailed",
		msg: "Borsh serialization failed"
	},
	{
		code: 6601,
		name: "DeserializationFailed",
		msg: "Borsh deserialization failed"
	},
	{
		code: 6602,
		name: "HeapFull",
		msg: "Heap is full"
	},
	{
		code: 6603,
		name: "InvalidSlot",
		msg: "Current slot is before the last updated slot"
	},
	{
		code: 6604,
		name: "EpochIsInfinity",
		msg: "Epoch is infinity"
	},
	{
		code: 6605,
		name: "InvalidTimestamp",
		msg: "Timestamp is invalid"
	},
	{
		code: 6606,
		name: "InvalidEpoch",
		msg: "Epoch is invalid"
	},
	{
		code: 6607,
		name: "EpochOverflow",
		msg: "Epoch overflowed"
	},
	{
		code: 6608,
		name: "InvalidLighthouseProgramID",
		msg: "Lighthouse program ID is invalid"
	},
	{
		code: 6609,
		name: "ExtraInstructionFound",
		msg: "Extra instruction found in transaction"
	},
	{
		code: 6610,
		name: "InvalidLighthouseInstructionCount",
		msg: "Invalid number of Lighthouse program instructions"
	},
	{
		code: 6611,
		name: "InvalidSignature",
		msg: "Invalid BLS signature"
	},
	{
		code: 6612,
		name: "ValueAlreadySet",
		msg: "Value already set"
	},
	{
		code: 6613,
		name: "InvalidValueSetterIndex",
		msg: "Invalid value setter index"
	},
	{
		code: 6614,
		name: "NotAllNodesVotedForBlsPublicKey",
		msg: "Not all nodes have voted for the BLS public key"
	},
	{
		code: 6615,
		name: "KeysharesIndexOutOfBounds",
		msg: "Keyshares index out of bounds"
	},
	{
		code: 6616,
		name: "RecoveryKeyMaterialNotSet",
		msg: "Recovery key material not set"
	},
	{
		code: 6617,
		name: "RecoveryInitAlreadyFinalized",
		msg: "Recovery already finalized"
	},
	{
		code: 6618,
		name: "InvalidRecoveryPeersCount",
		msg: "Invalid number of recovery peers"
	},
	{
		code: 6619,
		name: "BlsPublicKeyZero",
		msg: "BLS public key is zero"
	},
	{
		code: 6620,
		name: "MustNotBeCalledViaCpi",
		msg: "This instruction must be called directly, not via CPI"
	},
	{
		code: 6621,
		name: "FeePriceExceedsMax",
		msg: "Fee price exceeds maximum allowed"
	},
	{
		code: 6622,
		name: "NoFeesToClaim",
		msg: "No fees available to claim"
	},
	{
		code: 6700,
		name: "MxeNotInRecoveryState",
		msg: "MXE is not in recovery state"
	},
	{
		code: 6701,
		name: "MxeAlreadyInRecovery",
		msg: "MXE is already in recovery state"
	},
	{
		code: 6702,
		name: "BackupKeygenNotComplete",
		msg: "Backup MXE keygen is not complete"
	},
	{
		code: 6703,
		name: "RecoveryAuthorityMismatch",
		msg: "Authority mismatch between original and backup MXE"
	},
	{
		code: 6704,
		name: "RecoveryPeersNotInitialized",
		msg: "Recovery peers account not initialized"
	},
	{
		code: 6705,
		name: "InvalidRecoveryPeerOffset",
		msg: "Invalid peer offset for recovery share submission"
	},
	{
		code: 6706,
		name: "NotRecoveryPeer",
		msg: "Signer is not a valid recovery peer"
	},
	{
		code: 6707,
		name: "RecoveryExecutionAlreadyFinalized",
		msg: "Recovery execution already finalized"
	},
	{
		code: 6708,
		name: "RecoveryThresholdNotMet",
		msg: "Recovery threshold not met"
	},
	{
		code: 6709,
		name: "RecoveryExecutionNotFinalized",
		msg: "Recovery execution not finalized"
	},
	{
		code: 6710,
		name: "RecoveryComputationNotFailed",
		msg: "Previous computation did not fail, cannot requeue"
	},
	{
		code: 6711,
		name: "RecoveryActiveComputationExists",
		msg: "Cannot close recovery with active computation"
	},
	{
		code: 6712,
		name: "RecoveryExecutionNotSuccess",
		msg: "Callback requires successful execution status"
	},
	{
		code: 6713,
		name: "BackupClusterNotSet",
		msg: "Backup MXE cluster is not set"
	},
	{
		code: 6714,
		name: "ShareAlreadySubmitted",
		msg: "Share already submitted"
	},
	{
		code: 6715,
		name: "ArithmeticOverflow",
		msg: "Arithmetic overflow"
	},
	{
		code: 6716,
		name: "MxeInRecoveryState",
		msg: "MXE is in recovery state, cannot queue new computations"
	}
];
var types = [
	{
		name: "AbortReason",
		type: {
			kind: "enum",
			variants: [
				{
					name: "InvalidMAC"
				},
				{
					name: "ExpectedSentShare"
				},
				{
					name: "ExpectedFieldElement"
				},
				{
					name: "ExpectedAbort"
				},
				{
					name: "MalformedData"
				},
				{
					name: "ComputationFailed"
				},
				{
					name: "InternalError"
				},
				{
					name: "PreprocessingStreamError"
				},
				{
					name: "DivisionByZero"
				},
				{
					name: "NoSignature"
				},
				{
					name: "InvalidSignature"
				},
				{
					name: "PrimitiveError"
				},
				{
					name: "InvalidBatchLength"
				},
				{
					name: "QuadraticNonResidue"
				},
				{
					name: "BitConversionError"
				},
				{
					name: "ChannelClosed"
				},
				{
					name: "TimeoutElapsed"
				}
			]
		}
	},
	{
		name: "AcccountAccessInfo",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: "u16"
				}
			]
		}
	},
	{
		name: "AccountArgument",
		type: {
			kind: "struct",
			fields: [
				{
					name: "pubkey",
					type: "pubkey"
				},
				{
					name: "offset",
					type: "u32"
				},
				{
					name: "length",
					type: "u32"
				}
			]
		}
	},
	{
		name: "Activation",
		type: {
			kind: "struct",
			fields: [
				{
					name: "activation_epoch",
					docs: [
						"epoch for the cluster was activated. Epoch::INFINITY if inactive."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "deactivation_epoch",
					docs: [
						"epoch for the cluster to be deactivated. Epoch::INFINITY if none."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				}
			]
		}
	},
	{
		name: "ArgumentList",
		docs: [
			"Container for arguments that separates small inline values from large indexed data"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "args",
					type: {
						vec: {
							defined: {
								name: "ArgumentRef"
							}
						}
					}
				},
				{
					name: "byte_arrays",
					type: {
						vec: {
							array: [
								"u8",
								32
							]
						}
					}
				},
				{
					name: "plaintext_numbers",
					type: {
						vec: "u64"
					}
				},
				{
					name: "values_128_bit",
					type: {
						vec: "u128"
					}
				},
				{
					name: "accounts",
					type: {
						vec: {
							defined: {
								name: "AccountArgument"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "ArgumentRef",
		docs: [
			"A reference to an argument - stores small values that don't affect alignment inline and large",
			"values as indices."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool",
					fields: [
						"bool"
					]
				},
				{
					name: "PlaintextU8",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextI8",
					fields: [
						"i8"
					]
				},
				{
					name: "PlaintextU16",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextU32",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextU64",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextU128",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextFloat",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedBool",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedU8",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedU16",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedU32",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedU64",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedU128",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedFloat",
					fields: [
						"u8"
					]
				},
				{
					name: "X25519Pubkey",
					fields: [
						"u8"
					]
				},
				{
					name: "ArcisEd25519Signature",
					fields: [
						"u8"
					]
				},
				{
					name: "Account",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextI16",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextI32",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextI64",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextI128",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedI8",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedI16",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedI32",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedI64",
					fields: [
						"u8"
					]
				},
				{
					name: "EncryptedI128",
					fields: [
						"u8"
					]
				},
				{
					name: "PlaintextPoint",
					fields: [
						"u8"
					]
				}
			]
		}
	},
	{
		name: "ArxNode",
		type: {
			kind: "struct",
			fields: [
				{
					name: "x25519_pubkey",
					docs: [
						"X25519 public key for usage when being a key recovery peer. MUST BE AT byte index 8 - 40"
					],
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "primary_staking_account",
					type: "pubkey"
				},
				{
					name: "metadata",
					type: {
						defined: {
							name: "NodeMetadata"
						}
					}
				},
				{
					name: "config",
					type: {
						defined: {
							name: "ArxNodeConfig"
						}
					}
				},
				{
					name: "cluster_membership",
					docs: [
						"The offsets of the cluster the node is a member of."
					],
					type: {
						defined: {
							name: "ClusterMembership"
						}
					}
				},
				{
					name: "cu_capacity_claim",
					type: "u64"
				},
				{
					name: "is_active",
					type: "bool"
				},
				{
					name: "bls_pubkey",
					docs: [
						"BLS public key for this node (64 bytes compressed G2 point for alt-bn128)"
					],
					type: {
						defined: {
							name: "BN254G2BLSPublicKey"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ArxNodeConfig",
		type: {
			kind: "struct",
			fields: [
				{
					name: "authority",
					docs: [
						"Admin key for node management operations"
					],
					type: "pubkey"
				},
				{
					name: "callback_authority",
					docs: [
						"Key used to sign computation callbacks - separated for operational security"
					],
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "BN254G2BLSPublicKey",
		type: {
			kind: "struct",
			fields: [
				{
					array: [
						"u8",
						64
					]
				}
			]
		}
	},
	{
		name: "CallbackAccount",
		docs: [
			"A callback account to be provided to a computation.",
			"We don't specify signer, since node operators can't sign."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "pubkey",
					type: "pubkey"
				},
				{
					name: "is_writable",
					type: "bool"
				}
			]
		}
	},
	{
		name: "CallbackComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "CallbackInstruction",
		docs: [
			"A custom callback instruction with its own program ID and discriminator."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "program_id",
					type: "pubkey"
				},
				{
					name: "discriminator",
					type: "bytes"
				},
				{
					name: "accounts",
					type: {
						vec: {
							defined: {
								name: "CallbackAccount"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "CircuitSource",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Local",
					fields: [
						{
							defined: {
								name: "LocalCircuitSource"
							}
						}
					]
				},
				{
					name: "OnChain",
					fields: [
						{
							defined: {
								name: "OnChainCircuitSource"
							}
						}
					]
				},
				{
					name: "OffChain",
					fields: [
						{
							defined: {
								name: "OffChainCircuitSource"
							}
						}
					]
				}
			]
		}
	},
	{
		name: "ClaimFailureEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "ClockAccount",
		docs: [
			"An account storing the current network epoch"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "start_epoch",
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "current_epoch",
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "start_epoch_timestamp",
					type: {
						defined: {
							name: "Timestamp"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "Cluster",
		type: {
			kind: "struct",
			fields: [
				{
					name: "td_info",
					type: {
						option: {
							defined: {
								name: "NodeMetadata"
							}
						}
					}
				},
				{
					name: "authority",
					type: {
						option: "pubkey"
					}
				},
				{
					name: "cluster_size",
					type: "u16"
				},
				{
					name: "activation",
					type: {
						defined: {
							name: "Activation"
						}
					}
				},
				{
					name: "max_capacity",
					type: "u64"
				},
				{
					name: "cu_price",
					docs: [
						"The price of compute units in this cluster, in micro-lamports (millionths of a lamport)."
					],
					type: "u64"
				},
				{
					name: "cu_price_proposals",
					docs: [
						"The proposals for the cu price proposals in the next epoch, in micro-lamports.",
						"Index 0 is always the current price, we allow `MAX_FEE_PROPS` at most."
					],
					type: {
						array: [
							"u64",
							32
						]
					}
				},
				{
					name: "last_updated_epoch",
					docs: [
						"The epoch this cluster was last updated.",
						"Used to determine if the cluster needs to be updated."
					],
					type: {
						defined: {
							name: "Epoch"
						}
					}
				},
				{
					name: "nodes",
					type: {
						vec: {
							defined: {
								name: "NodeRef"
							}
						}
					}
				},
				{
					name: "pending_nodes",
					type: {
						vec: "u32"
					}
				},
				{
					name: "bls_public_key",
					docs: [
						"BLS public key for the cluster (64 bytes compressed G2 point for alt-bn128)",
						"Set only when all nodes have submitted and agreed on the aggregated pubkey"
					],
					type: {
						defined: {
							name: "SetUnset",
							generics: [
								{
									kind: "type",
									type: {
										defined: {
											name: "BN254G2BLSPublicKey"
										}
									}
								}
							]
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ClusterMembership",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Inactive"
				},
				{
					name: "Active",
					fields: [
						"u32"
					]
				},
				{
					name: "Proposed",
					fields: [
						"u32"
					]
				}
			]
		}
	},
	{
		name: "ComputationAccount",
		docs: [
			"A computation execution call to a [super::mxe::ComputationDefinitionAccount]."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "payer",
					type: "pubkey"
				},
				{
					name: "mxe_program_id",
					docs: [
						"The program ID of the MXE that this computation is associated with."
					],
					type: "pubkey"
				},
				{
					name: "computation_definition_offset",
					docs: [
						"The offset of the corresponding [super::mxe::ComputationDefinitionAccount]."
					],
					type: "u32"
				},
				{
					name: "execution_fee",
					docs: [
						"The execution fee for the execution."
					],
					type: {
						defined: {
							name: "ExecutionFee"
						}
					}
				},
				{
					name: "slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "status",
					type: {
						defined: {
							name: "ComputationStatus"
						}
					}
				},
				{
					name: "arguments",
					type: {
						defined: {
							name: "ArgumentList"
						}
					}
				},
				{
					name: "custom_callback_instructions",
					type: {
						vec: {
							defined: {
								name: "CallbackInstruction"
							}
						}
					}
				},
				{
					name: "callback_transactions_required",
					type: "u8"
				},
				{
					name: "callback_transactions_submitted_bm",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ComputationDefinitionAccount",
		docs: [
			"An account representing a [ComputationDefinition] in a MXE."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "finalization_authority",
					docs: [
						"The authority that is allowed to finalize a computation execution (callback).",
						"This is distinct from `upload_auth` (in `OnChainCircuitSource`) which controls the",
						"computation definition lifecycle (uploading/finalizing the definition itself).",
						"If set to None, anyone can finalize the computation execution."
					],
					type: {
						option: "pubkey"
					}
				},
				{
					name: "cu_amount",
					docs: [
						"The amount of CUs this computation will use."
					],
					type: "u64"
				},
				{
					name: "definition",
					docs: [
						"The interface of the computation to execute."
					],
					type: {
						defined: {
							name: "ComputationDefinitionMeta"
						}
					}
				},
				{
					name: "circuit_source",
					docs: [
						"Where to fetch the actual raw circuit to execute."
					],
					type: {
						defined: {
							name: "CircuitSource"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "ComputationDefinitionMeta",
		docs: [
			"A computation definition for execution in a MXE."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "circuit_len",
					type: "u32"
				},
				{
					name: "signature",
					type: {
						defined: {
							name: "ComputationSignature"
						}
					}
				}
			]
		}
	},
	{
		name: "ComputationDefinitionRaw",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "compiled_circuit",
					docs: [
						"The length here is meaningless."
					],
					type: {
						array: [
							"u8",
							0
						]
					}
				}
			]
		}
	},
	{
		name: "ComputationReference",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "priority_fee",
					type: "u64"
				},
				{
					name: "accs",
					type: {
						array: [
							{
								defined: {
									name: "AcccountAccessInfo"
								}
							},
							12
						]
					}
				}
			]
		}
	},
	{
		name: "ComputationSignature",
		docs: [
			"The signature of a computation defined in a [ComputationDefinition]."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "parameters",
					docs: [
						"The input parameters of the computation."
					],
					type: {
						vec: {
							defined: {
								name: "Parameter"
							}
						}
					}
				},
				{
					name: "outputs",
					docs: [
						"The output(s) of the computation."
					],
					type: {
						vec: {
							defined: {
								name: "Output"
							}
						}
					}
				}
			]
		}
	},
	{
		name: "ComputationStatus",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Queued"
				},
				{
					name: "Finalized"
				}
			]
		}
	},
	{
		name: "Epoch",
		docs: [
			"The network epoch"
		],
		type: {
			kind: "struct",
			fields: [
				"u64"
			]
		}
	},
	{
		name: "ExecutingPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		generics: [
			{
				kind: "const",
				name: "MAX_PARRALLEL_COMPUTATIONS",
				type: "usize"
			}
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				},
				{
					name: "counter",
					type: "u64"
				},
				{
					name: "execpool_index",
					type: {
						array: [
							"u64",
							{
								generic: "MAX_PARRALLEL_COMPUTATIONS"
							}
						]
					}
				},
				{
					name: "currently_executing",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							{
								generic: "MAX_PARRALLEL_COMPUTATIONS"
							}
						]
					}
				}
			]
		}
	},
	{
		name: "ExecutionFailure",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Serialization"
				},
				{
					name: "Router"
				},
				{
					name: "Circuit"
				},
				{
					name: "Inputs"
				},
				{
					name: "ProtocolInit"
				},
				{
					name: "ProtocolRun"
				},
				{
					name: "Abort",
					fields: [
						{
							defined: {
								name: "AbortReason"
							}
						}
					]
				},
				{
					name: "KeyRecoveryFailure",
					fields: [
						{
							defined: {
								name: "KeyRecoveryFailureReason"
							}
						}
					]
				}
			]
		}
	},
	{
		name: "ExecutionFee",
		type: {
			kind: "struct",
			fields: [
				{
					name: "base_fee",
					docs: [
						"The base fee for the computation."
					],
					type: "u64"
				},
				{
					name: "priority_fee",
					docs: [
						"The additional fee to enforce priortized execution in the mempool."
					],
					type: "u64"
				},
				{
					name: "output_delivery_fee",
					docs: [
						"A fee for output delivery fees (i.e. tx fees)."
					],
					type: "u64"
				}
			]
		}
	},
	{
		name: "ExecutionStatus",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Success"
				},
				{
					name: "Failure",
					fields: [
						{
							defined: {
								name: "ExecutionFailure"
							}
						},
						{
							array: [
								"u8",
								32
							]
						}
					]
				}
			]
		}
	},
	{
		name: "FailureClaimAccountHeader",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "is_complete",
					type: "bool"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				},
				{
					name: "challenge_end_slot",
					type: "u64"
				},
				{
					name: "poster",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "FeePool",
		type: {
			kind: "struct",
			fields: [
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "FinalizeComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "FinalizeFailureDataEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "InitComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "KeyRecoveryEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				},
				{
					name: "backup_mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "KeyRecoveryFailureReason",
		type: {
			kind: "enum",
			variants: [
				{
					name: "KeysDigestMismatch"
				},
				{
					name: "X25519PubkeyMismatch"
				},
				{
					name: "Ed25519VerifyingKeyMismatch"
				},
				{
					name: "ElGamalPubkeyMismatch"
				},
				{
					name: "TooManyCorruptPeers"
				},
				{
					name: "Serialization"
				},
				{
					name: "NoPubkeysSet"
				},
				{
					name: "AccountNotFound"
				}
			]
		}
	},
	{
		name: "LargeExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "100"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "LargeMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "LargeMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "LargeMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "LargeMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							100
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "LocalCircuitSource",
		type: {
			kind: "enum",
			variants: [
				{
					name: "MxeKeygen"
				},
				{
					name: "MxeKeyRecoveryInit"
				},
				{
					name: "MxeKeyRecoveryFinalize"
				}
			]
		}
	},
	{
		name: "MXEAccount",
		docs: [
			"A MPC Execution Environment."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "cluster",
					docs: [
						"The cluster executing the MXE."
					],
					type: {
						option: "u32"
					}
				},
				{
					name: "keygen_offset",
					docs: [
						"The offset used for the keygen computation account.",
						"Stored so requeue_mxe_keygen can find the computation account."
					],
					type: "u64"
				},
				{
					name: "key_recovery_init_offset",
					docs: [
						"The offset used for the key recovery init computation account.",
						"Stored so queue_key_recovery_init can find the computation account."
					],
					type: "u64"
				},
				{
					name: "mxe_program_id",
					docs: [
						"The program ID of the program that this MXE is associated with. Needed so that when we",
						"index this account offchain we can find out what program it is associated with."
					],
					type: "pubkey"
				},
				{
					name: "authority",
					docs: [
						"The management authority of the MXE."
					],
					type: {
						option: "pubkey"
					}
				},
				{
					name: "utility_pubkeys",
					docs: [
						"The utility pubkeys, consisting of",
						"- x25519 pubkey (32 bytes), used for key exchange",
						"- ed25519 verifying key (32 bytes), used for signature verification",
						"- ElGamal pubkey (32 bytes), used for c-spl",
						"- ElGamal pubkey validity proof (64 bytes), used for c-spl"
					],
					type: {
						defined: {
							name: "SetUnset",
							generics: [
								{
									kind: "type",
									type: {
										defined: {
											name: "UtilityPubkeys"
										}
									}
								}
							]
						}
					}
				},
				{
					name: "lut_offset_slot",
					type: "u64"
				},
				{
					name: "computation_definitions",
					docs: [
						"The offsets of all [ComputationDefinitionAccount]s of this MXE."
					],
					type: {
						vec: "u32"
					}
				},
				{
					name: "status",
					docs: [
						"The status of this MXE (Active or Recovery)."
					],
					type: {
						defined: {
							name: "MxeStatus"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "MediumExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "10"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "MediumMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "MediumMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "MediumMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "MediumMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							10
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "MempoolSize",
		type: {
			kind: "enum",
			variants: [
				{
					name: "Tiny"
				},
				{
					name: "Small"
				},
				{
					name: "Medium"
				},
				{
					name: "Large"
				}
			]
		}
	},
	{
		name: "MxeRecoveryAccount",
		docs: [
			"Account for tracking key recovery execution state.",
			"PDA seeds: [\"mxe_recovery\", backup_mxe_pubkey, original_mxe_pubkey]"
		],
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "key_recovery_finalize_offset",
					docs: [
						"The computation offset for the queued key_recovery_finalize circuit."
					],
					type: "u64"
				},
				{
					name: "shares",
					docs: [
						"The shares submitted by recovery peers. Each peer submits RESCUE_KEY_COUNT (5) field",
						"elements. Each field element is 32 bytes. Zeros indicate not yet uploaded."
					],
					type: {
						array: [
							{
								array: [
									{
										array: [
											"u8",
											32
										]
									},
									5
								]
							},
							100
						]
					}
				},
				{
					name: "original_mxe_pubkey",
					type: "pubkey"
				},
				{
					name: "backup_mxe_pubkey",
					type: "pubkey"
				},
				{
					name: "is_finalized",
					docs: [
						"Whether the recovery has been finalized (threshold met and marked ready)."
					],
					type: "u8"
				},
				{
					name: "_padding2",
					docs: [
						"Padding to ensure struct size is u64 aligned (6 bytes)"
					],
					type: {
						array: [
							"u8",
							6
						]
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "MxeStatus",
		docs: [
			"The status of an MXE."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "Active"
				},
				{
					name: "Recovery"
				}
			]
		}
	},
	{
		name: "NodeMetadata",
		docs: [
			"location as [ISO 3166-1 alpha-2](https://www.iso.org/iso-3166-country-codes.html) country code"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "ip",
					docs: [
						"[Ipv4Addr], represented by it's 4 octects"
					],
					type: {
						array: [
							"u8",
							4
						]
					}
				},
				{
					name: "peer_id",
					docs: [
						"Needed for MPC protocol"
					],
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "location",
					type: "u8"
				}
			]
		}
	},
	{
		name: "NodeRef",
		docs: [
			"A reference to a node in the cluster.",
			"The offset is to derive the Node Account.",
			"The current_total_rewards is the total rewards the node has received so far in the current",
			"epoch."
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "offset",
					type: "u32"
				},
				{
					name: "current_total_rewards",
					docs: [
						"Current total rewards the node has received in the current epoch in lamports."
					],
					type: "u64"
				},
				{
					name: "vote",
					type: "u8"
				}
			]
		}
	},
	{
		name: "OffChainCircuitSource",
		type: {
			kind: "struct",
			fields: [
				{
					name: "source",
					type: "string"
				},
				{
					name: "hash",
					type: {
						array: [
							"u8",
							32
						]
					}
				}
			]
		}
	},
	{
		name: "OnChainCircuitSource",
		type: {
			kind: "struct",
			fields: [
				{
					name: "is_completed",
					docs: [
						"Specifies if the circuit for this computation has been fully uploaded,",
						"as this can take multiple transactions due to the circuit size."
					],
					type: "bool"
				},
				{
					name: "upload_auth",
					docs: [
						"The authority that is allowed to upload circuit data and finalize the computation",
						"definition. This controls the definition lifecycle, distinct from",
						"`finalization_authority` (in `ComputationDefinitionAccount`) which controls computation",
						"execution finalization."
					],
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "Operator",
		type: {
			kind: "struct",
			fields: [
				{
					name: "node_offsets",
					type: {
						vec: "u32"
					}
				},
				{
					name: "meta",
					type: {
						defined: {
							name: "OperatorMeta"
						}
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "OperatorMeta",
		docs: [
			"location as [ISO 3166-1 alpha-2](https://www.iso.org/iso-3166-country-codes.html) country code"
		],
		type: {
			kind: "struct",
			fields: [
				{
					name: "url",
					docs: [
						"URL should point to a JSON containing the following fields:",
						"- `name`: String, the name of the operator",
						"- `description`: String, a description of the operator",
						"- `icon`: String, a URL to an icon representing the operator",
						"- `url`: String, a URL to the operator's website"
					],
					type: "string"
				},
				{
					name: "location",
					type: "u8"
				}
			]
		}
	},
	{
		name: "Output",
		docs: [
			"An output of a computation.",
			"We currently don't support encrypted outputs yet since encrypted values are passed via",
			"data objects."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool"
				},
				{
					name: "PlaintextU8"
				},
				{
					name: "PlaintextU16"
				},
				{
					name: "PlaintextU32"
				},
				{
					name: "PlaintextU64"
				},
				{
					name: "PlaintextU128"
				},
				{
					name: "Ciphertext"
				},
				{
					name: "ArcisX25519Pubkey"
				},
				{
					name: "PlaintextFloat"
				},
				{
					name: "PlaintextPoint"
				},
				{
					name: "PlaintextI8"
				},
				{
					name: "PlaintextI16"
				},
				{
					name: "PlaintextI32"
				},
				{
					name: "PlaintextI64"
				},
				{
					name: "PlaintextI128"
				}
			]
		}
	},
	{
		name: "Parameter",
		docs: [
			"A parameter of a computation.",
			"We differentiate between plaintext and encrypted parameters and data objects.",
			"Plaintext parameters are directly provided as their value.",
			"Encrypted parameters are provided as an offchain reference to the data.",
			"Data objects are provided as a reference to the data object account."
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "PlaintextBool"
				},
				{
					name: "PlaintextU8"
				},
				{
					name: "PlaintextU16"
				},
				{
					name: "PlaintextU32"
				},
				{
					name: "PlaintextU64"
				},
				{
					name: "PlaintextU128"
				},
				{
					name: "Ciphertext"
				},
				{
					name: "ArcisX25519Pubkey"
				},
				{
					name: "ArcisSignature"
				},
				{
					name: "PlaintextFloat"
				},
				{
					name: "PlaintextI8"
				},
				{
					name: "PlaintextI16"
				},
				{
					name: "PlaintextI32"
				},
				{
					name: "PlaintextI64"
				},
				{
					name: "PlaintextI128"
				},
				{
					name: "PlaintextPoint"
				}
			]
		}
	},
	{
		name: "QueueComputationEvent",
		type: {
			kind: "struct",
			fields: [
				{
					name: "computation_offset",
					type: "u64"
				},
				{
					name: "mxe_program_id",
					type: "pubkey"
				}
			]
		}
	},
	{
		name: "RecoveryClusterAccount",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "recovery_peers",
					docs: [
						"The offsets of nodes in our key recovery cluster. 0 means null in this context.",
						"DO NOT PUT ANYTHING BEFORE THE RECOVERY_PEERS FIELD, IT'S EXPECTED TO BE AT OFFSET 8."
					],
					type: {
						array: [
							"u32",
							100
						]
					}
				},
				{
					name: "recovery_key_material",
					type: {
						defined: {
							name: "RecoveryKeyMaterial"
						}
					}
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							2
						]
					}
				},
				{
					name: "bump",
					type: "u8"
				}
			]
		}
	},
	{
		name: "RecoveryKeyMaterial",
		serialization: "bytemuck",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "nonce",
					type: {
						array: [
							"u8",
							16
						]
					}
				},
				{
					name: "encrypted_mxe_keys",
					type: {
						array: [
							{
								array: [
									"u8",
									32
								]
							},
							13
						]
					}
				},
				{
					name: "key_material_hash",
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "recovery_keyshares",
					type: {
						array: [
							{
								array: [
									{
										array: [
											"u8",
											32
										]
									},
									5
								]
							},
							100
						]
					}
				},
				{
					name: "bls_sig",
					type: {
						array: [
							"u8",
							64
						]
					}
				},
				{
					name: "status",
					type: "u8"
				}
			]
		}
	},
	{
		name: "SetUnset",
		docs: [
			"Utility struct to store a value that needs to be set by a certain number of participants (keys",
			"in our case). Once all participants have set the value, the value is considered set and we only",
			"store it once."
		],
		generics: [
			{
				kind: "type",
				name: "T"
			}
		],
		type: {
			kind: "enum",
			variants: [
				{
					name: "Set",
					fields: [
						{
							generic: "T"
						}
					]
				},
				{
					name: "Unset",
					fields: [
						{
							generic: "T"
						},
						{
							vec: "bool"
						}
					]
				}
			]
		}
	},
	{
		name: "SmallExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "3"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "SmallMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "SmallMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "SmallMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "SmallMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							3
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "Timestamp",
		type: {
			kind: "struct",
			fields: [
				{
					name: "timestamp",
					type: "u64"
				}
			]
		}
	},
	{
		name: "TinyExecPool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "ExecutingPool",
							generics: [
								{
									kind: "const",
									value: "1"
								}
							]
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempool",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "transparent"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "inner",
					type: {
						defined: {
							name: "TinyMempoolInner"
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInner",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "last_updated_slot",
					type: "u64"
				},
				{
					name: "slot_counter",
					type: "u16"
				},
				{
					name: "bump",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							5
						]
					}
				},
				{
					name: "computations",
					type: {
						defined: {
							name: "TinyMempoolInnerBuffer"
						}
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInnerBuffer",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "elems",
					type: {
						array: [
							{
								defined: {
									name: "TinyMempoolInnerBufferHeap"
								}
							},
							180
						]
					}
				},
				{
					name: "valid_bits",
					docs: [
						"Bit array tracking which slots are valid (1 = valid, 0 = stale)",
						"1 bit per slot, packed into bytes. For $buffer_length=180, this is 23 bytes."
					],
					type: {
						array: [
							"u8",
							23
						]
					}
				},
				{
					name: "start_index",
					type: "u8"
				},
				{
					name: "length",
					type: "u8"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							7
						]
					}
				}
			]
		}
	},
	{
		name: "TinyMempoolInnerBufferHeap",
		serialization: "bytemuckunsafe",
		repr: {
			kind: "c"
		},
		type: {
			kind: "struct",
			fields: [
				{
					name: "entries",
					type: {
						array: [
							{
								defined: {
									name: "ComputationReference"
								}
							},
							1
						]
					}
				},
				{
					name: "count",
					type: "u16"
				},
				{
					name: "padding",
					type: {
						array: [
							"u8",
							6
						]
					}
				}
			]
		}
	},
	{
		name: "UtilityPubkeys",
		type: {
			kind: "struct",
			fields: [
				{
					name: "x25519_pubkey",
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "ed25519_verifying_key",
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "elgamal_pubkey",
					type: {
						array: [
							"u8",
							32
						]
					}
				},
				{
					name: "pubkey_validity_proof",
					type: {
						array: [
							"u8",
							64
						]
					}
				}
			]
		}
	}
];
var arcium = {
	address: address,
	metadata: metadata,
	instructions: instructions,
	accounts: accounts,
	events: events,
	errors: errors,
	types: types
};

var ARCIUM_IDL_MODULE = /*#__PURE__*/Object.freeze({
    __proto__: null,
    accounts: accounts,
    address: address,
    default: arcium,
    errors: errors,
    events: events,
    instructions: instructions,
    metadata: metadata,
    types: types
});

// Handle both ESM (ts-node wraps as {default: ...}) and bundled (direct) imports
const ARCIUM_IDL = (arcium ?? ARCIUM_IDL_MODULE);
/**
 * The deployed address of the Arcium program, as specified in the IDL.
 */
const ARCIUM_ADDR = ARCIUM_IDL.address;

/**
 * Seed for ClockAccount PDA
 * @constant {string}
 */
const CLOCK_ACC_SEED = 'ClockAccount';
/**
 * Seed for FeePool PDA
 * @constant {string}
 */
const POOL_ACC_SEED = 'FeePool';
/**
 * Seed for ComputationAccount PDA
 * @constant {string}
 */
const COMPUTATION_ACC_SEED = 'ComputationAccount';
/**
 * Seed for Mempool PDA
 * @constant {string}
 */
const MEMPOOL_ACC_SEED = 'Mempool';
/**
 * Seed for ExecutingPoolAccount PDA
 * @constant {string}
 */
const EXEC_POOL_ACC_SEED = 'Execpool';
/**
 * Seed for ClusterAccount PDA
 * @constant {string}
 */
const CLUSTER_ACC_SEED = 'Cluster';
/**
 * Seed for ArxNodeAccount PDA
 * @constant {string}
 */
const ARX_NODE_ACC_SEED = 'ArxNode';
/**
 * Seed for MXE Account PDA
 * @constant {string}
 */
const MXE_ACCOUNT_SEED = 'MXEAccount';
/**
 * Seed for CompDefAccount PDA
 * @constant {string}
 */
const COMP_DEF_ACC_SEED = 'ComputationDefinitionAccount';
/**
 * Seed for RecoveryClusterAccount PDA
 * @constant {string}
 */
const RECOVERY_CLUSTER_ACC_SEED = 'RecoveryClusterAccount';
/**
 * Seed for MxeRecoveryAccount PDA
 * @constant {string}
 */
const MXE_RECOVERY_ACC_SEED = 'MxeRecoveryAccount';
/**
 * Seed for ComputationDefinitionRaw PDA
 * @constant {string}
 */
const RAW_CIRCUIT_ACC_SEED = 'ComputationDefinitionRaw';
/**
 * Maximum number of bytes that can be reallocated per instruction.
 * @constant {number}
 */
const MAX_REALLOC_PER_IX = 10240;
/**
 * Maximum number of bytes that can be uploaded in a single transaction with the upload instruction.
 * @constant {number}
 */
const MAX_UPLOAD_PER_TX_BYTES = 814;
/**
 * Maximum size of an account in bytes (10MB = 10 * 1024 * 1024).
 * @constant {number}
 */
const MAX_ACCOUNT_SIZE = 10485760;
/**
 * Maximum number of arcium embiggen instructions allowed in a single transaction (due to compute unit limits).
 * @constant {number}
 */
const MAX_EMBIGGEN_IX_PER_TX = 18;
/**
 * Size of account discriminator in bytes.
 * @constant {number}
 */
const DISCRIMINATOR_SIZE = 8;
/**
 * Size of offset buffer in bytes (u32).
 * @constant {number}
 */
const OFFSET_BUFFER_SIZE = 4;
/**
 * Size of computation definition offset slice in bytes.
 * @constant {number}
 */
const COMP_DEF_OFFSET_SIZE = 4;

/**
 * Returns the public key of the deployed Arcium program on Solana.
 * @returns The Arcium program's public key.
 */
function getArciumProgramId() {
    return new anchor.web3.PublicKey(ARCIUM_ADDR);
}
/**
 * Derives the computation account address for a given cluster and computation offset.
 * @param clusterOffset - The offset of the cluster this computation will be executed by.
 * @param computationOffset - The computation offset as an anchor.BN.
 * @returns The derived computation account public key.
 */
function getComputationAccAddress(clusterOffset, computationOffset) {
    const clOffsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    clOffsetBuffer.writeUInt32LE(clusterOffset, 0);
    const seeds = [Buffer.from(COMPUTATION_ACC_SEED), clOffsetBuffer, computationOffset.toArrayLike(Buffer, 'le', 8)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the mempool account address for a given cluster.
 * @param clusterOffset - The offset of the cluster.
 * @returns The derived mempool account public key.
 */
function getMempoolAccAddress(clusterOffset) {
    const clOffsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    clOffsetBuffer.writeUInt32LE(clusterOffset, 0);
    const seeds = [Buffer.from(MEMPOOL_ACC_SEED), clOffsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the executing pool account address for a given cluster.
 * @param clusterOffset - The offset of the cluster.
 * @returns The derived executing pool account public key.
 */
function getExecutingPoolAccAddress(clusterOffset) {
    const clOffsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    clOffsetBuffer.writeUInt32LE(clusterOffset, 0);
    const seeds = [Buffer.from(EXEC_POOL_ACC_SEED), clOffsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the fee pool account address.
 * @returns The derived fee pool account public key.
 */
function getFeePoolAccAddress() {
    const seeds = [Buffer.from(POOL_ACC_SEED)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the clock account address.
 * @returns The derived clock account public key.
 */
function getClockAccAddress() {
    const seeds = [Buffer.from(CLOCK_ACC_SEED)];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the cluster account address for a given offset.
 * @param clusterOffset - The cluster offset as a number.
 * @returns The derived cluster account public key.
 */
function getClusterAccAddress(clusterOffset) {
    const offsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    offsetBuffer.writeUInt32LE(clusterOffset, 0);
    const seeds = [Buffer.from(CLUSTER_ACC_SEED), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the ArxNode account address for a given offset.
 * @param nodeOffset - The ArxNode offset as a number.
 * @returns The derived ArxNode account public key.
 */
function getArxNodeAccAddress(nodeOffset) {
    const offsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    offsetBuffer.writeUInt32LE(nodeOffset, 0);
    const seeds = [Buffer.from(ARX_NODE_ACC_SEED), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the MXE account address for a given MXE program ID.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The derived MXE account public key.
 */
function getMXEAccAddress(mxeProgramId) {
    const seeds = [Buffer.from(MXE_ACCOUNT_SEED), mxeProgramId.toBuffer()];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the computation definition account address for a given MXE program ID and offset.
 * @param mxeProgramId - The public key of the MXE program.
 * @param compDefOffset - The computation definition offset as a number.
 * @returns The derived computation definition account public key.
 */
function getCompDefAccAddress(mxeProgramId, compDefOffset) {
    const offsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    offsetBuffer.writeUInt32LE(compDefOffset, 0);
    const seeds = [Buffer.from(COMP_DEF_ACC_SEED), mxeProgramId.toBuffer(), offsetBuffer];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the recovery cluster account address for a given MXE program ID.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The derived recovery cluster account public key.
 */
function getRecoveryClusterAccAddress(mxeProgramId) {
    const seeds = [Buffer.from(RECOVERY_CLUSTER_ACC_SEED), mxeProgramId.toBuffer()];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the MXE recovery account address for a key recovery session.
 * @param backupMxeProgramId - The public key of the backup MXE program that will take over.
 * @param originalMxeProgramId - The public key of the original MXE program being recovered.
 * @returns The derived MXE recovery account public key.
 */
function getMxeRecoveryAccAddress(backupMxeProgramId, originalMxeProgramId) {
    const seeds = [
        Buffer.from(MXE_RECOVERY_ACC_SEED),
        backupMxeProgramId.toBuffer(),
        originalMxeProgramId.toBuffer(),
    ];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the raw circuit account address for a given computation definition and index.
 * @param compDefPubkey - The public key of the computation definition account.
 * @param rawCircuitIndex - The index of the raw circuit account (0-based).
 * @returns The derived raw circuit account public key.
 */
function getRawCircuitAccAddress(compDefPubkey, rawCircuitIndex) {
    const seeds = [
        Buffer.from(RAW_CIRCUIT_ACC_SEED),
        compDefPubkey.toBuffer(),
        Buffer.from([rawCircuitIndex]),
    ];
    return generateArciumPDAFrom(seeds)[0];
}
/**
 * Derives the address lookup table address for an MXE program.
 * @param mxeProgramId - The public key of the MXE program.
 * @param lutOffset - The index of the lookup table, to be fetched from the mxe account.
 * @returns The derived address lookup table public key.
 */
function getLookupTableAddress(mxeProgramId, lutOffset) {
    const mxeAccount = getMXEAccAddress(mxeProgramId);
    const lutIndexBuffer = lutOffset.toArrayLike(Buffer, 'le', 8);
    const seeds = [mxeAccount.toBuffer(), lutIndexBuffer];
    return PublicKey.findProgramAddressSync(seeds, AddressLookupTableProgram.programId)[0];
}
/**
 * Generates a program-derived address (PDA) from the provided seeds and the Arcium program ID.
 * @param seeds - An array of Buffer seeds used for PDA derivation.
 * @returns A tuple containing the derived public key and the bump seed.
 */
function generateArciumPDAFrom(seeds) {
    const programId = getArciumProgramId();
    return PublicKey.findProgramAddressSync(seeds, programId);
}

const TINY_MEMPOOL_ACC_NAME = 'tinyMempool';
const TINY_MEMPOOL_DISCRIMINATOR = [
    176,
    33,
    67,
    108,
    73,
    135,
    110,
    166,
];
const TINY_EXECPOOL_ACC_NAME = 'tinyExecPool';
const TINY_EXECPOOL_DISCRIMINATOR = [
    80,
    245,
    5,
    90,
    154,
    189,
    190,
    172,
];
const SMALL_MEMPOOL_ACC_NAME = 'smallMempool';
const SMALL_MEMPOOL_DISCRIMINATOR = [
    123,
    153,
    151,
    118,
    126,
    71,
    73,
    92,
];
const SMALL_EXECPOOL_ACC_NAME = 'smallExecPool';
const SMALL_EXECPOOL_DISCRIMINATOR = [
    37,
    147,
    249,
    253,
    217,
    136,
    3,
    87,
];
const MEDIUM_MEMPOOL_ACC_NAME = 'mediumMempool';
const MEDIUM_MEMPOOL_DISCRIMINATOR = [
    10,
    249,
    58,
    39,
    255,
    231,
    199,
    168,
];
const MEDIUM_EXECPOOL_ACC_NAME = 'mediumExecPool';
const MEDIUM_EXECPOOL_DISCRIMINATOR = [
    97,
    117,
    128,
    202,
    213,
    76,
    5,
    163,
];
const LARGE_MEMPOOL_ACC_NAME = 'largeMempool';
const LARGE_MEMPOOL_DISCRIMINATOR = [
    16,
    168,
    90,
    235,
    249,
    207,
    73,
    223,
];
const LARGE_EXECPOOL_ACC_NAME = 'largeExecPool';
const LARGE_EXECPOOL_DISCRIMINATOR = [
    147,
    145,
    148,
    170,
    30,
    13,
    43,
    216,
];
const MEMPOOL_DISCRIMINATOR_MAP = {
    [TINY_MEMPOOL_DISCRIMINATOR.toString()]: TINY_MEMPOOL_ACC_NAME,
    [SMALL_MEMPOOL_DISCRIMINATOR.toString()]: SMALL_MEMPOOL_ACC_NAME,
    [MEDIUM_MEMPOOL_DISCRIMINATOR.toString()]: MEDIUM_MEMPOOL_ACC_NAME,
    [LARGE_MEMPOOL_DISCRIMINATOR.toString()]: LARGE_MEMPOOL_ACC_NAME,
};
const EXECPOOL_DISCRIMINATOR_MAP = {
    [TINY_EXECPOOL_DISCRIMINATOR.toString()]: TINY_EXECPOOL_ACC_NAME,
    [SMALL_EXECPOOL_DISCRIMINATOR.toString()]: SMALL_EXECPOOL_ACC_NAME,
    [MEDIUM_EXECPOOL_DISCRIMINATOR.toString()]: MEDIUM_EXECPOOL_ACC_NAME,
    [LARGE_EXECPOOL_DISCRIMINATOR.toString()]: LARGE_EXECPOOL_ACC_NAME,
};
/**
 * Fetches and decodes the mempool account info for any mempool account size.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mempoolAccPubkey - The public key of the mempool account.
 * @returns The decoded mempool account info.
 * @throws Error if the account cannot be fetched or the discriminator is unknown.
 */
async function getMempoolAccInfo(provider, mempoolAccPubkey) {
    const accData = await provider.connection.getAccountInfo(mempoolAccPubkey);
    if (accData === null) {
        throw new Error(`Failed to fetch mempool account ${mempoolAccPubkey.toBase58()}`);
    }
    const discriminator = Array.from(accData.data.subarray(0, DISCRIMINATOR_SIZE)).toString();
    const accName = MEMPOOL_DISCRIMINATOR_MAP[discriminator];
    if (accName === undefined) {
        throw new Error(`Unknown mempool account discriminator: ${discriminator}`);
    }
    const program = getArciumProgram(provider);
    return program.coder.accounts.decode(accName, accData.data);
}
/**
 * Fetches and decodes the executing pool account info for any pool size.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param executingPoolAccPubkey - The public key of the executing pool account.
 * @returns The decoded executing pool account info.
 * @throws Error if the account cannot be fetched or the discriminator is unknown.
 */
async function getExecutingPoolAccInfo(provider, executingPoolAccPubkey) {
    const accData = await provider.connection.getAccountInfo(executingPoolAccPubkey);
    if (accData === null) {
        throw new Error(`Failed to fetch executing pool account ${executingPoolAccPubkey.toBase58()}`);
    }
    const discriminator = Array.from(accData.data.subarray(0, DISCRIMINATOR_SIZE)).toString();
    const accName = EXECPOOL_DISCRIMINATOR_MAP[discriminator];
    if (accName === undefined) {
        throw new Error(`Unknown executing pool account discriminator: ${discriminator}`);
    }
    const program = getArciumProgram(provider);
    return program.coder.accounts.decode(accName, accData.data);
}
/**
 * Returns all computation references in the mempool for a given account.
 * Only non-stake computations are included.
 * @param arciumProgram - The Anchor program instance.
 * @param address - The public key of the mempool account.
 * @returns Array of ComputationReference objects.
 */
async function getComputationsInMempool(arciumProgram, address) {
    const mempool = await getMempoolAccInfo(arciumProgram.provider, address);
    const startIndex = mempool.inner.computations.startIndex;
    const length = mempool.inner.computations.length;
    const elems = mempool.inner.computations.elems;
    function isValid(validBits, idx) {
        const byte = idx >>> 3;
        const bit = idx & 7;
        if (byte >= validBits.length) {
            // This should never happen, so we'll want to know about it
            throw new Error(`isValid: byte ${byte} >= validBits.length ${validBits.length}`);
        }
        return (validBits[byte] & (1 << bit)) !== 0;
    }
    // Handle circular buffer wraparound
    const refs = [];
    for (let i = 0; i < length; i++) {
        const idx = (startIndex + i) % elems.length;
        // Only save non-stake computations
        if (isValid(mempool.inner.computations.validBits, idx)) {
            refs.push(...elems[idx].entries);
        }
    }
    return refs
        .flat()
        .filter((ref) => !isNullRef(ref));
}
/**
 * Calculates priority fee statistics for computations in a mempool.
 * @param arciumProgram - The Anchor program instance.
 * @param mempoolAddress - The public key of the mempool account.
 * @returns Priority fee statistics (mean, median, min, max, count).
 */
async function getMempoolPriorityFeeStats(arciumProgram, mempoolAddress) {
    const refs = await getComputationsInMempool(arciumProgram, mempoolAddress);
    if (refs.length === 0) {
        const zero = new anchor.BN(0);
        return { mean: zero, median: zero, min: zero, max: zero, count: 0 };
    }
    const fees = refs.map(ref => ref.priorityFee).sort((a, b) => a.cmp(b));
    const sum = fees.reduce((acc, fee) => acc.add(fee), new anchor.BN(0));
    const mean = sum.div(new anchor.BN(fees.length));
    const mid = Math.floor(fees.length / 2);
    const median = fees.length % 2 === 0
        ? fees[mid - 1].add(fees[mid]).div(new anchor.BN(2))
        : fees[mid];
    return {
        mean,
        median,
        min: fees[0],
        max: fees[fees.length - 1],
        count: fees.length,
    };
}
/**
 * Helper function to fetch a specific utility key from the MXE account.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mxeProgramId - The public key of the MXE program.
 * @param field - The field name to extract ('x25519Pubkey' or 'ed25519VerifyingKey').
 * @returns The utility key as a Uint8Array, or null if not set.
 */
async function getMXEUtilityKey(provider, mxeProgramId, field) {
    const program = getArciumProgram(provider);
    const mxeAccAddress = getMXEAccAddress(mxeProgramId);
    const mxeAccInfo = await program.account.mxeAccount.fetch(mxeAccAddress);
    if ('set' in mxeAccInfo.utilityPubkeys) {
        const setData = mxeAccInfo.utilityPubkeys.set;
        return new Uint8Array(setData[0][field]);
    }
    else if ('unset' in mxeAccInfo.utilityPubkeys) {
        const unsetData = mxeAccInfo.utilityPubkeys.unset;
        if (unsetData[1].every(Boolean)) {
            return new Uint8Array(unsetData[0][field]);
        }
    }
    return null;
}
/**
 * Fetches and extracts the MXE x25519 public key from the MXE account.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The MXE's x25519 public key as a Uint8Array, or null if not set.
 */
async function getMXEPublicKey(provider, mxeProgramId) {
    return getMXEUtilityKey(provider, mxeProgramId, 'x25519Pubkey');
}
/**
 * Fetches and extracts the MXE arcis ed25519 verifying key from the MXE account.
 * @param provider - The Anchor provider to use for fetching accounts.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The MXE's arcis ed25519 verifying key as a Uint8Array, or null if not set.
 */
async function getMXEArcisEd25519VerifyingKey(provider, mxeProgramId) {
    return getMXEUtilityKey(provider, mxeProgramId, 'ed25519VerifyingKey');
}
/**
 * Determines the current state of a circuit based on its on-chain configuration.
 * @internal Called internally by `uploadCircuit` - most users don't need this directly.
 * @param circuitSource - The circuitSource field from ComputationDefinitionAccount.
 * @returns The current state of the circuit.
 */
function getCircuitState(circuitSource) {
    if (!('onChain' in circuitSource) || !circuitSource.onChain) {
        return 'Offchain';
    }
    if (circuitSource.onChain[0].isCompleted) {
        return 'OnchainFinalized';
    }
    return 'OnchainPending';
}
/**
 * Uploads a circuit to the blockchain, splitting it into multiple accounts if necessary.
 * @param provider - The Anchor provider to use for transactions.
 * @param circuitName - The name of the circuit.
 * @param mxeProgramId - The public key of the MXE program.
 * @param rawCircuit - The raw circuit data as a Uint8Array.
 * @param logging - Whether to log progress (default: true).
 * @param chunkSize - The number of upload transactions to send in parallel (default: 500).
 * @returns An array of transaction signatures for all upload and finalize transactions.
 */
async function uploadCircuit(provider, circuitName, mxeProgramId, rawCircuit, logging = true, chunkSize = 500) {
    const compDefAccInfo = getCompDefAccInfo(circuitName, mxeProgramId);
    const program = getArciumProgram(provider);
    const compDefAcc = await program.account.computationDefinitionAccount.fetch(compDefAccInfo.pubkey);
    // Type assertion at boundary where Anchor's fetch() returns the account data
    const state = getCircuitState(compDefAcc.circuitSource);
    if (state !== 'OnchainPending') {
        optionalLog(logging, `Circuit ${circuitName} skipped: ${state}`);
        return [];
    }
    // 9 = 8-byte discriminator + 1-byte bump for ComputationDefinitionRaw account
    const numAccs = Math.ceil(rawCircuit.length / (MAX_ACCOUNT_SIZE - 9));
    const sigs = [];
    const uploadPromises = [];
    for (let i = 0; i < numAccs; i++) {
        uploadPromises.push(uploadToCircuitAcc(provider, program, rawCircuit.subarray(i * (MAX_ACCOUNT_SIZE - 9), (i + 1) * (MAX_ACCOUNT_SIZE - 9)), i, compDefAccInfo, mxeProgramId, logging, chunkSize));
    }
    sigs.push(...(await Promise.all(uploadPromises)).flat());
    const finalizeCompDefTx = await buildFinalizeCompDefTx(provider, compDefAccInfo.offset, mxeProgramId);
    sigs.push(await signAndSendWithBlockhash(provider, finalizeCompDefTx, await provider.connection.getLatestBlockhash()));
    return sigs;
}
async function queueKeyRecoveryInit(provider, clusterOffset, mxeProgramId, confirmOptions) {
    const program = getArciumProgram(provider);
    const sigs = [];
    const queueKeyRecoveryInitTx = await program.methods
        .queueKeyRecoveryInit(clusterOffset, mxeProgramId)
        .accounts({
        signer: provider.publicKey,
        mxeProgram: mxeProgramId,
    })
        .transaction();
    sigs.push(await signAndSendWithBlockhash(provider, queueKeyRecoveryInitTx, await provider.connection.getLatestBlockhash({ commitment: confirmOptions?.commitment || "confirmed" }), confirmOptions));
    return sigs;
}
/**
 * Builds a transaction to finalize a computation definition.
 * @param provider - The Anchor provider to use for transactions.
 * @param compDefOffset - The offset of the computation definition.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns The transaction to finalize the computation definition.
 */
async function buildFinalizeCompDefTx(provider, compDefOffset, mxeProgramId) {
    const program = getArciumProgram(provider);
    const compDefOffsetBuffer = Buffer.alloc(OFFSET_BUFFER_SIZE);
    compDefOffsetBuffer.writeUInt32LE(compDefOffset, 0);
    return program.methods
        .finalizeComputationDefinition(compDefOffset, mxeProgramId)
        .accounts({
        signer: provider.publicKey,
    })
        .transaction();
}
async function uploadToCircuitAcc(provider, program, rawCircuitPart, rawCircuitIndex, compDefAccInfo, mxeProgramId, shouldLog = true, chunkSize = 500) {
    const rawCircuitPda = getRawCircuitAccAddress(compDefAccInfo.pubkey, rawCircuitIndex);
    const existingAcc = await provider.connection.getAccountInfo(rawCircuitPda);
    // Skip entirely if account exists with correct size (pre-seeded at genesis or already uploaded)
    // Account layout: 8-byte discriminator + 1-byte bump + circuit data
    const requiredAccountSize = rawCircuitPart.length + 9;
    if (existingAcc !== null && existingAcc.data.length >= requiredAccountSize) {
        optionalLog(shouldLog, `Raw circuit acc ${rawCircuitIndex} already exists with sufficient size, skipping`);
        return [];
    }
    const sigs = [];
    if (existingAcc === null) {
        const initTx = await program.methods
            .initRawCircuitAcc(compDefAccInfo.offset, mxeProgramId, rawCircuitIndex)
            .accounts({
            signer: provider.publicKey,
        })
            .rpc();
        optionalLog(shouldLog, `Initiated raw circuit acc with raw circuit index ${rawCircuitIndex}`);
        sigs.push(initTx);
    }
    if (rawCircuitPart.length > MAX_REALLOC_PER_IX) {
        // We only need to add size if the init didn't already make us big enough
        const nonAsyncTxCount = Math.ceil(rawCircuitPart.length / (MAX_REALLOC_PER_IX * MAX_EMBIGGEN_IX_PER_TX));
        for (let i = 0; i < nonAsyncTxCount; i++) {
            optionalLog(shouldLog, `Sending resize tx ${i} of ${nonAsyncTxCount}`);
            // eslint-disable-next-line no-await-in-loop
            const tx = await buildResizeTx(program, provider.publicKey, compDefAccInfo, mxeProgramId, rawCircuitIndex, MAX_REALLOC_PER_IX
                + i * (MAX_REALLOC_PER_IX * MAX_EMBIGGEN_IX_PER_TX), rawCircuitPart.length);
            // eslint-disable-next-line no-await-in-loop
            const blockInfo = await provider.connection.getLatestBlockhash();
            sigs.push(
            // eslint-disable-next-line no-await-in-loop
            await signAndSendWithBlockhash(provider, tx, blockInfo));
            optionalLog(shouldLog, `Sent resize tx ${i} of ${nonAsyncTxCount}`);
        }
    }
    optionalLog(shouldLog, 'Done sending resize txs');
    // The previous txs have allocated all the space we need now, so we can send the remaining upload txs async to one another now
    const remainingTxCount = Math.ceil(rawCircuitPart.length / MAX_UPLOAD_PER_TX_BYTES);
    optionalLog(shouldLog, `Sending ${remainingTxCount} upload txs`);
    const remainingTxs = [];
    const blockInfo = await provider.connection.getLatestBlockhash();
    for (let i = 0; i < remainingTxCount; i += chunkSize) {
        optionalLog(shouldLog, `Sending chunk ${i / chunkSize + 1} of ${Math.ceil(remainingTxCount / chunkSize)}`);
        // Array to hold promises for the current chunk
        const chunkPromises = [];
        // Handle the last chunk
        const currentChunkSize = Math.min(chunkSize, remainingTxCount - i);
        for (let j = 0; j < currentChunkSize; j++) {
            const offset = MAX_UPLOAD_PER_TX_BYTES * (i + j);
            // eslint-disable-next-line no-await-in-loop
            const tx = await buildUploadCircuitTx(program, provider.publicKey, compDefAccInfo, mxeProgramId, Buffer.copyBytesFrom(rawCircuitPart, offset, MAX_UPLOAD_PER_TX_BYTES), offset, rawCircuitIndex);
            chunkPromises.push(signAndSendWithBlockhash(provider, tx, blockInfo));
        }
        // Wait for the current chunk to complete before proceeding
        // eslint-disable-next-line no-await-in-loop
        const chunkResults = await Promise.all(chunkPromises);
        // Add the results of the current chunk to the main array
        remainingTxs.push(...chunkResults);
        optionalLog(shouldLog, `Done sending chunk ${i / chunkSize + 1} of ${Math.ceil(remainingTxCount / chunkSize)}`);
    }
    return sigs.concat(remainingTxs);
}
async function buildResizeTx(program, signerPubkey, compDefAccInfo, mxeProgramId, rawCircuitIndex, currentSize, requiredSize) {
    const ix = await program.methods
        .embiggenRawCircuitAcc(compDefAccInfo.offset, mxeProgramId, rawCircuitIndex)
        .accounts({
        signer: signerPubkey,
    })
        .instruction();
    const resizeSize = Math.min(requiredSize - currentSize, MAX_EMBIGGEN_IX_PER_TX * MAX_REALLOC_PER_IX);
    // We might alloc a bit too much here, but that's ok because we fix it in the upload tx
    const ixCount = Math.ceil(resizeSize / MAX_REALLOC_PER_IX);
    const tx = new anchor.web3.Transaction();
    for (let i = 0; i < ixCount; i++) {
        tx.add(ix);
    }
    return tx;
}
async function buildUploadCircuitTx(program, signerPubkey, compDefAccInfo, mxeProgramId, bytes, circuitOffset, rawCircuitIndex) {
    if (bytes.length > MAX_UPLOAD_PER_TX_BYTES) {
        throw new Error(`Upload circuit bytes must be ${MAX_UPLOAD_PER_TX_BYTES} bytes or less per tx`);
    }
    let bytesInner = bytes;
    if (bytesInner.length < MAX_UPLOAD_PER_TX_BYTES) {
        const paddedBytes = Buffer.allocUnsafe(MAX_UPLOAD_PER_TX_BYTES);
        paddedBytes.set(bytesInner);
        bytesInner = paddedBytes;
    }
    return program.methods
        .uploadCircuit(compDefAccInfo.offset, mxeProgramId, rawCircuitIndex, Array.from(bytesInner), circuitOffset)
        .accounts({
        signer: signerPubkey,
    })
        .transaction();
}
async function signAndSendWithBlockhash(provider, tx, block, confirmOptions) {
    // eslint-disable-next-line no-param-reassign
    tx.recentBlockhash = block.blockhash;
    // eslint-disable-next-line no-param-reassign
    tx.lastValidBlockHeight = block.lastValidBlockHeight;
    return provider.sendAndConfirm(tx, [], confirmOptions || { commitment: 'confirmed' });
}
/**
 * Returns the base seed for an Arcium account, given its name.
 * @param accName - The name of the account.
 * @returns The base seed as a Uint8Array.
 */
function getArciumAccountBaseSeed(accName) {
    return Buffer.from(accName, 'utf-8');
}
/**
 * Computes the offset for a computation definition account, based on the circuit name.
 * @param circuitName - The name of the circuit.
 * @returns The offset as a 4-byte Uint8Array.
 */
function getCompDefAccOffset(circuitName) {
    const hash = new Uint8Array(sha256([Buffer.from(circuitName, 'utf-8')]));
    return hash.slice(0, COMP_DEF_OFFSET_SIZE);
}
/**
 * Returns an Anchor program instance for the Arcium program.
 * @param provider - The Anchor provider to use.
 * @returns The Anchor program instance for Arcium.
 */
function getArciumProgram(provider) {
    return new Program(ARCIUM_IDL, provider);
}
/**
 * Returns the public key and offset for a computation definition account, given the circuit name and MXE program ID.
 * @param circuitName - The name of the circuit.
 * @param mxeProgramId - The public key of the MXE program.
 * @returns An object containing the public key and offset for the computation definition account.
 */
function getCompDefAccInfo(circuitName, mxeProgramId) {
    const offset = getCompDefAccOffset(circuitName);
    const pda = getCompDefAccPDA(getArciumProgramId(), mxeProgramId, offset);
    return { pubkey: pda, offset: Buffer.from(offset).readUInt32LE(0) };
}
/**
 * Returns the PDA for a computation definition account, given the program ID, MXE program ID, and offset.
 * @param arciumProgramId - The public key of the Arcium program.
 * @param mxeProgramId - The public key of the MXE program.
 * @param offset - The offset as a Uint8Array.
 * @returns The PDA for the computation definition account.
 */
function getCompDefAccPDA(arciumProgramId, mxeProgramId, offset) {
    return anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(COMP_DEF_ACC_SEED, 'utf-8'), mxeProgramId.toBuffer(), offset], arciumProgramId)[0];
}
/**
 * Sets an MXE to Recovery status, initiating the key recovery process.
 * @param provider - The Anchor provider to use for transactions.
 * @param mxeProgramId - The public key of the MXE program to recover.
 * @returns The transaction signature.
 */
async function recoverMxe(provider, mxeProgramId) {
    const program = getArciumProgram(provider);
    const tx = await program.methods
        .recoverMxe(mxeProgramId)
        .accountsPartial({
        authority: provider.publicKey,
        mxeProgram: mxeProgramId,
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}
/**
 * Initializes key recovery execution by creating the MxeRecoveryAccount and
 * registering the key_recovery_final computation definition on the backup MXE.
 * This is split into two parts due to Solana's 10KB per-instruction allocation limit.
 * @param provider - The Anchor provider to use for transactions.
 * @param originalMxeProgramId - The public key of the original MXE program being recovered.
 * @param backupMxeProgramId - The public key of the backup MXE program that will take over.
 * @returns The transaction signature from part2.
 */
async function initKeyRecoveryExecution(provider, originalMxeProgramId, backupMxeProgramId) {
    // Part 1: Create MxeRecoveryAccount with partial size
    const program = getArciumProgram(provider);
    const tx1 = await program.methods
        .initKeyRecoveryExecutionPart1(originalMxeProgramId, backupMxeProgramId)
        .accountsPartial({
        payer: provider.publicKey,
        originalMxeProgram: originalMxeProgramId,
        backupMxeProgram: backupMxeProgramId,
    })
        .transaction();
    await signAndSendWithBlockhash(provider, tx1, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
    // Part 2: Reallocate to full size and create computation definition
    const tx2 = await program.methods
        .initKeyRecoveryExecutionPart2(originalMxeProgramId, backupMxeProgramId)
        .accountsPartial({
        authority: provider.publicKey,
        payer: provider.publicKey,
        originalMxeProgram: originalMxeProgramId,
        backupMxeProgram: backupMxeProgramId,
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx2, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}
/**
 * Submits a re-encrypted key recovery share from a recovery peer.
 * Recovery peers must decrypt shares using their X25519 private key and re-encrypt
 * them for the backup MXE before submission.
 * @param provider - The Anchor provider to use for transactions.
 * @param originalMxeProgramId - The public key of the original MXE program being recovered.
 * @param backupMxeProgramId - The public key of the backup MXE program.
 * @param nodeOffset - The ARX node offset of the recovery peer.
 * @param peerIndex - The index of this peer in the recovery peers list.
 * @param share - The re-encrypted share: 5 field elements of 32 bytes each (160 bytes total).
 * @returns The transaction signature.
 */
async function submitKeyRecoveryShare(provider, originalMxeProgramId, backupMxeProgramId, nodeOffset, peerIndex, share) {
    const program = getArciumProgram(provider);
    // Convert to array of 5 elements, each 32 bytes
    const shareArrays = share.map(elem => Array.from(elem));
    if (shareArrays.length !== 5) {
        throw new Error(`Share must contain exactly 5 elements, got ${shareArrays.length}`);
    }
    for (let i = 0; i < 5; i++) {
        if (shareArrays[i].length !== 32) {
            throw new Error(`Share element ${i} must be exactly 32 bytes, got ${shareArrays[i].length}`);
        }
    }
    const tx = await program.methods
        .submitKeyRecoveryShare(originalMxeProgramId, backupMxeProgramId, nodeOffset, peerIndex, shareArrays)
        .accountsPartial({
        nodeSigner: provider.publicKey,
        originalMxeProgram: originalMxeProgramId,
        backupMxeProgram: backupMxeProgramId,
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}
/**
 * Finalizes key recovery execution after the submission threshold is met.
 * This queues the key_recovery_finalize MPC computation on the backup cluster.
 * @param provider - The Anchor provider to use for transactions.
 * @param originalMxeProgramId - The public key of the original MXE program being recovered.
 * @param backupMxeProgramId - The public key of the backup MXE program.
 * @param clusterOffset - The cluster offset where the backup MXE is deployed.
 * @param keyRecoveryFinalizeOffset - The computation offset for the key_recovery_finalize computation.
 * @returns The transaction signature.
 */
async function finalizeKeyRecoveryExecution(provider, originalMxeProgramId, backupMxeProgramId, clusterOffset, keyRecoveryFinalizeOffset) {
    const program = getArciumProgram(provider);
    const tx = await program.methods
        .finalizeKeyRecoveryExecution(originalMxeProgramId, backupMxeProgramId, clusterOffset)
        .accountsPartial({
        authority: provider.publicKey,
        payer: provider.publicKey,
        keyRecoveryFinalizeComputation: getComputationAccAddress(clusterOffset, keyRecoveryFinalizeOffset),
        executingPool: getExecutingPoolAccAddress(clusterOffset),
        mempool: getMempoolAccAddress(clusterOffset),
        originalMxeProgram: originalMxeProgramId,
        backupMxeProgram: backupMxeProgramId,
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}
/**
 * Initializes an MXE (part 1). Due to Solana's 10KB per-instruction allocation limit,
 * this only partially allocates recovery_cluster_acc.
 * Call initMxePart2 afterwards to finish allocation and add keygen to mempool.
 * @param provider - The Anchor provider to use for transactions.
 * @param mxeProgramId - The public key to use as the MXE program ID.
 * @returns The transaction signature.
 */
async function initMxePart1(provider, mxeProgramId) {
    const program = getArciumProgram(provider);
    const tx = await program.methods
        .initMxePart1()
        .accountsPartial({
        signer: provider.publicKey,
        mxeProgram: mxeProgramId,
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}
/**
 * Finishes MXE initialization (part 2).
 * Reallocates recovery_cluster_acc to full size, initializes recovery_peers,
 * and adds the keygen computation to the mempool.
 * @param provider - The Anchor provider to use for transactions.
 * @param clusterOffset - The cluster offset to associate with the MXE.
 * @param mxeProgramId - The public key to use as the MXE program ID.
 * @param recoveryPeers - Array of 100 node offsets for recovery peers (0 for unused slots).
 * @param keygenOffset - The computation offset for the keygen computation.
 * @param keyRecoveryInitOffset - The computation offset for the key_recovery_init computation.
 * @param mxeAuthority - Optional authority for the MXE (defaults to provider.publicKey).
 * @returns The transaction signature.
 */
async function initMxePart2(provider, clusterOffset, mxeProgramId, recoveryPeers, keygenOffset, keyRecoveryInitOffset, lutOffset, mxeAuthority) {
    const program = getArciumProgram(provider);
    // Ensure recoveryPeers has exactly 100 elements
    const paddedRecoveryPeers = [...recoveryPeers];
    while (paddedRecoveryPeers.length < 100) {
        paddedRecoveryPeers.push(0);
    }
    if (paddedRecoveryPeers.length > 100) {
        throw new Error('recoveryPeers must have at most 100 elements');
    }
    const tx = await program.methods
        .initMxePart2(clusterOffset, mxeProgramId, paddedRecoveryPeers, keygenOffset, keyRecoveryInitOffset, lutOffset)
        .accountsPartial({
        signer: provider.publicKey,
        mxeProgram: mxeProgramId,
        poolAccount: getFeePoolAccAddress(),
        mxeAuthority: mxeAuthority ?? provider.publicKey,
        addressLookupTable: getLookupTableAddress(mxeProgramId, lutOffset),
    })
        .transaction();
    return signAndSendWithBlockhash(provider, tx, await provider.connection.getLatestBlockhash({ commitment: 'confirmed' }));
}

/**
 * Reads local Arcium environment information from environment variables.
 * Only available in Node.js and when testing locally.
 * @returns The local Arcium environment configuration.
 * @throws Error if called in a browser or if required environment variables are missing or invalid.
 */
function getArciumEnv() {
    if (isBrowser()) {
        throw new Error('Arcium local env is not available in browser.');
    }
    try {
        const arciumClusterOffset = Number(process.env.ARCIUM_CLUSTER_OFFSET);
        if (isNaN(arciumClusterOffset)) {
            throw new Error('ARCIUM_CLUSTER_OFFSET environment variable is not set or is invalid (NaN).');
        }
        return {
            arciumClusterOffset,
        };
    }
    catch (e) {
        throw new Error(`Encountered error while trying to parse env vars: ${e}`);
    }
}

/**
 * Waits for the finalization of a computation by listening for the finalizeComputationEvent.
 * Resolves with the transaction signature once the computation is finalized.
 * @param provider - The Anchor provider to use for event listening.
 * @param computationOffset - The offset of the computation to wait for.
 * @param mxeProgramId - The public key of the MXE program.
 * @param commitment - (Optional) The desired finality/commitment level (default: 'confirmed').
 * @returns The transaction signature of the finalization event.
 */
async function awaitComputationFinalization(provider, computationOffset, mxeProgramId, commitment = 'confirmed') {
    const arciumProgram = getArciumProgram(provider);
    const eventListener = new EventManager(arciumProgram.programId, provider, arciumProgram.coder);
    const finalizeComp = await awaitEvent(eventListener, 'finalizeComputationEvent', (e) => mxeProgramId.equals(e.mxeProgramId) && e.computationOffset.eq(computationOffset), commitment);
    return finalizeComp.sig;
}
/**
 * Waits for a specific event to occur, matching a custom check, and returns the event and its signature.
 * @param eventListener - The EventManager instance to use for listening.
 * @param eventName - The name of the event to listen for.
 * @param eventCheck - A predicate function to check if the event matches the desired criteria.
 * @param commitment - (Optional) The desired finality/commitment level (default: 'confirmed').
 * @returns An object containing the event and its transaction signature.
 */
async function awaitEvent(eventListener, eventName, eventCheck, commitment = 'confirmed') {
    const foundEvent = await new Promise((res) => {
        const listenerId = eventListener.addEventListener(eventName, (event, _slot, signature) => {
            if (eventCheck(event))
                res([event, signature, listenerId]);
        }, commitment);
    });
    await eventListener.removeEventListener(foundEvent[2]);
    return { event: foundEvent[0], sig: foundEvent[1] };
}

export { ARCIUM_ADDR, ARCIUM_IDL, Aes128Cipher, Aes192Cipher, Aes256Cipher, ArcisModule, ArcisType, ArcisValueField, CSplRescueCipher, CURVE25519_BASE_FIELD, CURVE25519_SCALAR_FIELD, CURVE25519_SCALAR_FIELD_MODULUS, IntegerInfo, Matrix, RescueCipher, RescueDesc, RescuePrimeHash, arcisEd25519, awaitComputationFinalization, buildFinalizeCompDefTx, createPacker, deserializeLE, finalizeKeyRecoveryExecution, generateRandomFieldElem, getArciumAccountBaseSeed, getArciumEnv, getArciumProgram, getArciumProgramId, getArxNodeAccAddress, getCircuitState, getClockAccAddress, getClusterAccAddress, getCompDefAccAddress, getCompDefAccOffset, getComputationAccAddress, getComputationsInMempool, getExecutingPoolAccAddress, getExecutingPoolAccInfo, getFeePoolAccAddress, getLookupTableAddress, getMXEAccAddress, getMXEArcisEd25519VerifyingKey, getMXEPublicKey, getMempoolAccAddress, getMempoolAccInfo, getMempoolPriorityFeeStats, getMxeRecoveryAccAddress, getRawCircuitAccAddress, getRecoveryClusterAccAddress, initKeyRecoveryExecution, initMxePart1, initMxePart2, isNullRef, positiveModulo, queueKeyRecoveryInit, randMatrix, recoverMxe, serializeLE, sha256, submitKeyRecoveryShare, toVec, uploadCircuit };
